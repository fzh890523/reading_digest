
# ls命令介绍
* ls [${path}...]
*默认字典序*
* ls -l [${path}...]
  ```shell
  # root @ localhost in /tmp/platform__thumbnail/nginx/lua/scripts [11:07:36] tty:pts/0 L:1 N:565
  $ ls -lu                       
  total 532
  -rw-r--r--. 1 root root 529580 Apr 22 20:40 1.png
  -rw-r--r--. 1 root root   4547 Apr 22 20:45 1.png__50x50.png
  -rw-r--r--. 1 root root   3154 Apr 25 11:07 test_thumbnail_file.lua

  # root @ localhost in /tmp/platform__thumbnail/nginx/lua/scripts [11:08:28] tty:pts/0 L:1 N:570
  $ ls -l
  total 532
  -rw-r--r--. 1 root root 529580 Sep 14  2015 1.png
  -rw-r--r--. 1 root root   4547 Apr 22 20:44 1.png__50x50.png
  -rw-r--r--. 1 root root   3154 Apr 25 11:07 test_thumbnail_file.lua

  # root @ localhost in /tmp/platform__thumbnail/nginx/lua/scripts [11:08:29] tty:pts/0 L:1 N:571
  $ vim test_thumbnail_file.lua

  # root @ localhost in /tmp/platform__thumbnail/nginx/lua/scripts [11:08:41] tty:pts/0 L:1 N:572
  $ ls -l
  total 532
  -rw-r--r--. 1 root root 529580 Sep 14  2015 1.png
  -rw-r--r--. 1 root root   4547 Apr 22 20:44 1.png__50x50.png
  -rw-r--r--. 1 root root   3154 Apr 25 11:07 test_thumbnail_file.lua

  # root @ localhost in /tmp/platform__thumbnail/nginx/lua/scripts [11:08:44] tty:pts/0 L:1 N:573
  $ ls -lu
  total 532
  -rw-r--r--. 1 root root 529580 Apr 22 20:40 1.png
  -rw-r--r--. 1 root root   4547 Apr 22 20:45 1.png__50x50.png
  -rw-r--r--. 1 root root   3154 Apr 25 11:08 test_thumbnail_file.lua
  ```
* ls -a
* ls -lu 显示最后访问时间
* ls -s  
  ```shell
  # root @ localhost in /tmp/platform__thumbnail/nginx/lua/scripts [11:02:30] tty:pts/0 L:1 N:559
  $ ls -s
  total 532
  520 1.png    8 1.png__50x50.png    4 test_thumbnail_file.lua

  # root @ localhost in /tmp/platform__thumbnail/nginx/lua/scripts [11:02:39] tty:pts/0 L:1 N:560
  $ ls -sl
  total 532
  520 -rw-r--r--. 1 root root 529580 Sep 14  2015 1.png
    8 -rw-r--r--. 1 root root   4547 Apr 22 20:44 1.png__50x50.png
    4 -rw-r--r--. 1 root root   3154 Apr 22 20:44 test_thumbnail_file.lua

  # root @ localhost in /tmp/platform__thumbnail/nginx/lua/scripts [11:02:43] tty:pts/0 L:1 N:561
  $ ls -l
  total 532
  -rw-r--r--. 1 root root 529580 Sep 14  2015 1.png
  -rw-r--r--. 1 root root   4547 Apr 22 20:44 1.png__50x50.png
  -rw-r--r--. 1 root root   3154 Apr 22 20:44 test_thumbnail_file.lua
  ```
* ls -t  时间排序
* ls -r  反向排序
* ls -F  显示文件类型（link后面+@，目录后面+/。 与-l选项好像冲突）
  ```shell
  $ ls -F /
  bin@  boot/  data/  dev/  etc/  home/  lib@  lib64@  media/  mnt/  opt/  proc/  root/  run/  sbin@  srv/  sys/  tmp/  usr/  var/  zookeeper_server.pid

  # root @ localhost in /tmp/platform__thumbnail/nginx/lua/scripts [11:00:21] tty:pts/0 L:1 N:553
  $ ls  /  
  bin  boot  data  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  zookeeper_server.pid

  # root @ localhost in /tmp/platform__thumbnail/nginx/lua/scripts [11:00:24] tty:pts/0 L:1 N:554
  $ ls -lF /
  total 36
  lrwxrwxrwx.   1 root root    7 Sep  1  2015 bin -> usr/bin/
  dr-xr-xr-x.   4 root root 4096 Jan 29 12:09 boot/
  drwxr-xr-x.  13 root root  133 Mar 16 18:03 data/
  drwxr-xr-x.  20 root root 3180 Apr 17 22:54 dev/
  drwxr-xr-x.  97 root root 8192 Apr 21 15:39 etc/
  drwxr-xr-x.   2 root root    6 Jun 10  2014 home/
  lrwxrwxrwx.   1 root root    7 Sep  1  2015 lib -> usr/lib/
  lrwxrwxrwx.   1 root root    9 Sep  1  2015 lib64 -> usr/lib64/
  drwxr-xr-x.   2 root root    6 Jun 10  2014 media/
  drwxr-xr-x.   4 root root   29 Sep  1  2015 mnt/
  drwxr-xr-x.   2 root root    6 Jun 10  2014 opt/
  dr-xr-xr-x. 255 root root    0 Apr 17 22:54 proc/
  dr-xr-x---.  29 root root 4096 Apr 25 11:00 root/
  drwxr-xr-x.  24 root root  680 Apr 18 00:49 run/
  lrwxrwxrwx.   1 root root    8 Sep  1  2015 sbin -> usr/sbin/
  drwxr-xr-x.   2 root root    6 Jun 10  2014 srv/
  dr-xr-xr-x.  13 root root    0 Apr 17 22:54 sys/
  drwxrwxrwt.  37 root root 4096 Apr 25 03:37 tmp/
  drwxr-xr-x.  13 root root 4096 Sep  1  2015 usr/
  drwxr-xr-x.  21 root root 4096 Apr 17 22:54 var/
  -rw-r--r--.   1 root root    5 Sep  7  2015 zookeeper_server.pid

  # root @ localhost in /tmp/platform__thumbnail/nginx/lua/scripts [11:00:50] tty:pts/0 L:1 N:555
  $ ls -l /
  total 36
  lrwxrwxrwx.   1 root root    7 Sep  1  2015 bin -> usr/bin
  dr-xr-xr-x.   4 root root 4096 Jan 29 12:09 boot
  drwxr-xr-x.  13 root root  133 Mar 16 18:03 data
  drwxr-xr-x.  20 root root 3180 Apr 17 22:54 dev
  drwxr-xr-x.  97 root root 8192 Apr 21 15:39 etc
  drwxr-xr-x.   2 root root    6 Jun 10  2014 home
  lrwxrwxrwx.   1 root root    7 Sep  1  2015 lib -> usr/lib
  lrwxrwxrwx.   1 root root    9 Sep  1  2015 lib64 -> usr/lib64
  drwxr-xr-x.   2 root root    6 Jun 10  2014 media
  drwxr-xr-x.   4 root root   29 Sep  1  2015 mnt
  drwxr-xr-x.   2 root root    6 Jun 10  2014 opt
  dr-xr-xr-x. 255 root root    0 Apr 17 22:54 proc
  dr-xr-x---.  29 root root 4096 Apr 25 11:00 root
  drwxr-xr-x.  24 root root  680 Apr 18 00:49 run
  lrwxrwxrwx.   1 root root    8 Sep  1  2015 sbin -> usr/sbin
  drwxr-xr-x.   2 root root    6 Jun 10  2014 srv
  dr-xr-xr-x.  13 root root    0 Apr 17 22:54 sys
  drwxrwxrwt.  37 root root 4096 Apr 25 03:37 tmp
  drwxr-xr-x.  13 root root 4096 Sep  1  2015 usr
  drwxr-xr-x.  21 root root 4096 Apr 17 22:54 var
  ```

```shell
NAME
       ls - list directory contents

SYNOPSIS
       ls [OPTION]... [FILE]...

DESCRIPTION
       List information about the FILEs (the current directory by default).  Sort entries alphabetically if none of -cftuvSUX nor --sort is specified.

       Mandatory arguments to long options are mandatory for short options too.

       -a, --all
              do not ignore entries starting with .

       -A, --almost-all
              do not list implied . and ..

       --author
              with -l, print the author of each file

       -b, --escape
              print C-style escapes for nongraphic characters

       --block-size=SIZE
              scale sizes by SIZE before printing them; e.g., '--block-size=M' prints sizes in units of 1,048,576 bytes; see SIZE format below

       -B, --ignore-backups
              do not list implied entries ending with ~

       -c     with -lt: sort by, and show, ctime (time of last modification of file status information); with -l: show ctime and sort by name; otherwise: sort by ctime, newest first

       -C     list entries by columns

       --color[=WHEN]
              colorize the output; WHEN can be 'never', 'auto', or 'always' (the default); more info below

       -d, --directory
              list directories themselves, not their contents

       -D, --dired
              generate output designed for Emacs' dired mode

       -f     do not sort, enable -aU, disable -ls --color

       -F, --classify
              append indicator (one of */=>@|) to entries

       --file-type
              likewise, except do not append '*'

       --format=WORD
              across -x, commas -m, horizontal -x, long -l, single-column -1, verbose -l, vertical -C

       --full-time
              like -l --time-style=full-iso

       -g     like -l, but do not list owner

             --group-directories-first
                    group directories before files;

                    can be augmented with a --sort option, but any use of --sort=none (-U) disables grouping

             -G, --no-group
                    in a long listing, don't print group names

             -h, --human-readable
                    with -l, print sizes in human readable format (e.g., 1K 234M 2G)

             --si   likewise, but use powers of 1000 not 1024

             -H, --dereference-command-line
                    follow symbolic links listed on the command line

             --dereference-command-line-symlink-to-dir
                    follow each command line symbolic link

                    that points to a directory

             --hide=PATTERN
                    do not list implied entries matching shell PATTERN (overridden by -a or -A)

             --indicator-style=WORD
                    append indicator with style WORD to entry names: none (default), slash (-p), file-type (--file-type), classify (-F)

             -i, --inode
                    print the index number of each file

             -I, --ignore=PATTERN
                    do not list implied entries matching shell PATTERN

             -k, --kibibytes
                    default to 1024-byte blocks for disk usage

             -l     use a long listing format

             -L, --dereference
                    when showing file information for a symbolic link, show information for the file the link references rather than for the link itself

             -m     fill width with a comma separated list of entries

             -n, --numeric-uid-gid
                    like -l, but list numeric user and group IDs

             -N, --literal
                    print raw entry names (don't treat e.g. control characters specially)

             -o     like -l, but do not list group information

             -p, --indicator-style=slash
                    append / indicator to directories

             -q, --hide-control-chars
                    print ? instead of nongraphic characters

             --show-control-chars
                    show nongraphic characters as-is (the default, unless program is 'ls' and output is a terminal)

             -Q, --quote-name
                    enclose entry names in double quotes

             --quoting-style=WORD
                    use quoting style WORD for entry names: literal, locale, shell, shell-always, c, escape

             -r, --reverse
                    reverse order while sorting

             -R, --recursive
                    list subdirectories recursively

             -s, --size
                    print the allocated size of each file, in blocks

             -S     sort by file size

             --sort=WORD
                    sort by WORD instead of name: none (-U), size (-S), time (-t), version (-v), extension (-X)

             --time=WORD
                    with -l, show time as WORD instead of default modification time: atime or access or use (-u) ctime or status (-c); also use specified time as sort key if --sort=time

             --time-style=STYLE
                    with  -l, show times using style STYLE: full-iso, long-iso, iso, locale, or +FORMAT; FORMAT is interpreted like in 'date'; if FORMAT is FORMAT1<newline>FORMAT2, then FORMAT1 applies to non-recent files and FORMAT2 to
                    recent files; if STYLE is prefixed with 'posix-', STYLE takes effect only outside the POSIX locale

             -t     sort by modification time, newest first

             -T, --tabsize=COLS
                    assume tab stops at each COLS instead of 8

             -u     with -lt: sort by, and show, access time; with -l: show access time and sort by name; otherwise: sort by access time

             -U     do not sort; list entries in directory order

             -v     natural sort of (version) numbers within text

             -w, --width=COLS
                    assume screen width instead of current value

             -x     list entries by lines instead of by columns

             -X     sort alphabetically by entry extension

            -1     list one file per line

            SELinux options:

            --lcontext
                   Display security context.   Enable -l. Lines will probably be too wide for most displays.

            -Z, --context
                   Display security context so it fits on most displays.  Displays only mode, user, group, security context and file name.

            --scontext
                   Display only security context and file name.

            --help display this help and exit

            --version
                   output version information and exit

            SIZE is an integer and optional unit (example: 10M is 10*1024*1024).  Units are K, M, G, T, P, E, Z, Y (powers of 1024) or KB, MB, ... (powers of 1000).

            Using color to distinguish file types is disabled both by default and with --color=never.  With --color=auto, ls emits color codes only when standard output is connected to a terminal.  The  LS_COLORS  environment  variable
            can change the settings.  Use the dircolors command to set it.

        Exit status:
            0      if OK,

            1      if minor problems (e.g., cannot access subdirectory),

            2      if serious trouble (e.g., cannot access command-line argument).

            GNU coreutils online help: <http://www.gnu.org/software/coreutils/> Report ls translation bugs to <http://translationproject.org/team/>
```

# 文件树
dir是特殊的文件，dir的内容是其下的文件信息列表（name、inode）（其中至少有两项： .和..）；
文件的内容是数据；

# ls如何工作

## 常见文件读写命令
can
more/less
od -c
dd

## 对dir的操作
open/read/close这些syscall用来操作dir并不是很方便。  因为不同的FS，dir的内容结构不同，自行解析的话太麻烦而且没有必要 - 交给system来做。
而是
```shell
$ man -k direct | egrep "read|open|close|seek"
closedir (3)         - close a directory
closedir (3p)        - close a directory stream
fdopendir (3)        - open a directory
openat (2)           - open a file relative to a directory file descriptor
opendir (3)          - open a directory
opendir (3p)         - open a directory
readdir (2)          - read directory entry
readdir (3)          - read a directory
readdir (3p)         - read a directory
readdir_r (3)        - read a directory
readdir_r (3p)       - read a directory
readlinkat (2)       - read value of a symbolic link relative to a directory file descriptor
seekdir (3)          - set the position of the next readdir() call in the directory stream.
seekdir (3p)         - set the position of a directory stream
TIFFWriteDirectory (3tiff) - write the current directory in an open TIFF file
TIFFReadDirectory (3tiff) - get the contents of the next directory in an open TIFF file
TIFFSetDirectory (3tiff) - set the current directory for an open TIFF file
```

**操作步骤**
1. opendir
2. readdir
3. closedir

### dirent dir条目
```shell
<dirent.h>(0P)                                                                                         POSIX Programmer's Manual                                                                                        <dirent.h>(0P)



NAME
       dirent.h - format of directory entries

SYNOPSIS
       #include <dirent.h>

DESCRIPTION
       The internal format of directories is unspecified.

       The <dirent.h> header shall define the following type:

       DIR    A type representing a directory stream.


       It shall also define the structure dirent which shall include the following members:


              ino_t  d_ino       File serial number.

              char   d_name[]    Name of entry.

       The type ino_t shall be defined as described in <sys/types.h> .

       The character array d_name is of unspecified size, but the number of bytes preceding the terminating null byte shall not exceed {NAME_MAX}.

       The following shall be declared as functions and may also be defined as macros. Function prototypes shall be provided.


              int            closedir(DIR *);
              DIR           *opendir(const char *);
              struct dirent *readdir(DIR *);

              int            readdir_r(DIR *restrict, struct dirent *restrict,
                                 struct dirent **restrict);

              void           rewinddir(DIR *);

              void           seekdir(DIR *, long);
              long           telldir(DIR *);


       The following sections are informative.

APPLICATION USAGE
      None.

RATIONALE
      Information  similar  to  that  in the <dirent.h> header is contained in a file <sys/dir.h> in 4.2 BSD and 4.3 BSD. The equivalent in these implementations of struct dirent from this volume of IEEE Std 1003.1-2001 is struct
      direct. The filename was changed because the name <sys/dir.h> was also used in earlier implementations to refer to definitions related to the older access method; this produced name conflicts. The name of the structure  was
      changed because this volume of IEEE Std 1003.1-2001 does not completely define what is in the structure, so it could be different on some implementations from struct direct.

      The name of an array of char of an unspecified size should not be used as an lvalue. Use of:


             sizeof(d_name)

      is incorrect; use:


             strlen(d_name)

      instead.

      The  array of char d_name is not a fixed size. Implementations may need to declare struct dirent with an array size for d_name of 1, but the actual number of characters provided matches (or only slightly exceeds) the length
      of the filename.

FUTURE DIRECTIONS
      None.
```

### readdir

#### readdir syscall (man 2 readdir)

```shell

READDIR(2)                                                                                             Linux Programmer's Manual                                                                                            READDIR(2)

NAME
       readdir - read directory entry

SYNOPSIS
       int readdir(unsigned int fd, struct old_linux_dirent *dirp,
                   unsigned int count);

       Note: There is no glibc wrapper for this system call; see NOTES.

DESCRIPTION
       This is not the function you are interested in.  Look at readdir(3) for the POSIX conforming C library interface.  This page documents the bare kernel system call interface, which is superseded by getdents(2).

       readdir() reads one old_linux_dirent structure from the directory referred to by the file descriptor fd into the buffer pointed to by dirp.  The argument count is ignored; at most one old_linux_dirent structure is read.

       The old_linux_dirent structure is declared as follows:

           struct old_linux_dirent {
               long  d_ino;              /* inode number */
               off_t d_off;              /* offset to this old_linux_dirent */
               unsigned short d_reclen;  /* length of this d_name */
               char  d_name[NAME_MAX+1]; /* filename (null-terminated) */
           }

       d_ino  is  an inode number.  d_off is the distance from the start of the directory to this old_linux_dirent.  d_reclen is the size of d_name, not counting the terminating null byte ('\0').  d_name is a null-terminated file‐
       name.

RETURN VALUE
       On success, 1 is returned.  On end of directory, 0 is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EBADF  Invalid file descriptor fd.

       EFAULT Argument points outside the calling process's address space.

       EINVAL Result buffer is too small.

       ENOENT No such directory.

       ENOTDIR
              File descriptor does not refer to a directory.

CONFORMING TO
       This system call is Linux-specific.

NOTES
       Glibc does not provide a wrapper for this system call; call it using syscall(2).  You will need to define the old_linux_dirent structure yourself.  However, probably you should use readdir(3) instead.

       This system call does not exist on x86-64.

SEE ALSO
       getdents(2), readdir(3)
```


#### readdir function (man 3 readdir)
```shell
READDIR(3)                                                                                             Linux Programmer's Manual                                                                                            READDIR(3)



NAME
       readdir, readdir_r - read a directory

SYNOPSIS
       #include <dirent.h>

       struct dirent *readdir(DIR *dirp);

       int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       readdir_r():
           _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE

DESCRIPTION
       The  readdir()  function  returns a pointer to a dirent structure representing the next directory entry in the directory stream pointed to by dirp.  It returns NULL on reaching the end of the directory stream or if an error
       occurred.

       On Linux, the dirent structure is defined as follows:

           struct dirent {
               ino_t          d_ino;       /* inode number */
               off_t          d_off;       /* not an offset; see NOTES */
               unsigned short d_reclen;    /* length of this record */
               unsigned char  d_type;      /* type of file; not supported
                                              by all file system types */
               char           d_name[256]; /* filename */
           };

       The only fields in the dirent structure that are mandated by POSIX.1 are: d_name[], of unspecified size, with at most NAME_MAX characters preceding the terminating null byte ('\0'); and (as an  XSI  extension)  d_ino.   The
       other fields are unstandardized, and not present on all systems; see NOTES below for some further details.

       The data returned by readdir() may be overwritten by subsequent calls to readdir() for the same directory stream.

       The readdir_r() function is a reentrant version of readdir().  It reads the next directory entry from the directory stream dirp, and returns it in the caller-allocated buffer pointed to by entry.  (See NOTES for information
       on allocating this buffer.)  A pointer to the returned item is placed in *result; if the end of the directory stream was encountered, then NULL is instead returned in *result.

RETURN VALUE
       On success, readdir() returns a pointer to a dirent structure.  (This structure may be statically allocated; do not attempt to free(3) it.)  If the end of the directory stream is reached, NULL is returned and errno  is  not
       changed.  If an error occurs, NULL is returned and errno is set appropriately.

       The readdir_r() function returns 0 on success.  On error, it returns a positive error number (listed under ERRORS).  If the end of the directory stream is reached, readdir_r() returns 0, and returns NULL in *result.

ERRORS
       EBADF  Invalid directory stream descriptor dirp.

ATTRIBUTES
   Multithreading (see pthreads(7))
       The readdir() function is not thread-safe.

       The readdir_r() function is thread-safe.

CONFORMING TO
       SVr4, 4.3BSD, POSIX.1-2001.

NOTES
      Only the fields d_name and d_ino are specified in POSIX.1-2001.  The remaining fields are available on many, but not all systems.  Under glibc, programs can check for the availability of the fields not defined in POSIX.1 by
      testing whether the macros _DIRENT_HAVE_D_NAMLEN, _DIRENT_HAVE_D_RECLEN, _DIRENT_HAVE_D_OFF, or _DIRENT_HAVE_D_TYPE are defined.

      The value returned in d_off is the same as would be returned by calling telldir(3) at the current position in the directory stream.  Be aware that despite its type and name, the d_off field is seldom any kind  of  directory
      offset on modern file systems.  Applications should treat this field as an opaque value, making no assumptions about its contents; see also telldir(3).

      Other  than Linux, the d_type field is available mainly only on BSD systems.  This field makes it possible to avoid the expense of calling lstat(2) if further actions depend on the type of the file.  If the _BSD_SOURCE fea‐
      ture test macro is defined, then glibc defines the following macro constants for the value returned in d_type:

      DT_BLK      This is a block device.

      DT_CHR      This is a character device.

      DT_DIR      This is a directory.

      DT_FIFO     This is a named pipe (FIFO).

      DT_LNK      This is a symbolic link.

      DT_REG      This is a regular file.

      DT_SOCK     This is a UNIX domain socket.

      DT_UNKNOWN  The file type is unknown.

      If the file type could not be determined, the value DT_UNKNOWN is returned in d_type.

      Currently, only some file systems (among them: Btrfs, ext2, ext3, and ext4) have full support for returning the file type in d_type.  All applications must properly handle a return of DT_UNKNOWN.

      Since POSIX.1 does not specify the size of the d_name field, and other nonstandard fields may precede that field within the dirent structure, portable applications that use  readdir_r()  should  allocate  the  buffer  whose
      address is passed in entry as follows:

          name_max = pathconf(dirpath, _PC_NAME_MAX);
          if (name_max == -1)         /* Limit not defined, or error */
              name_max = 255;         /* Take a guess */
          len = offsetof(struct dirent, d_name) + name_max + 1;
          entryp = malloc(len);

      (POSIX.1 requires that d_name is the last field in a struct dirent.)

SEE ALSO
      getdents(2), read(2), closedir(3), dirfd(3), ftw(3), offsetof(3), opendir(3), rewinddir(3), scandir(3), seekdir(3), telldir(3)

```

# 如何编写ls
见 code/ls_cmd/main1.code

# 编写ls -l

## ls -l的输出
```shell
lrwxrwxrwx.   1 root root    7 Sep  1  2015 bin -> usr/bin
dr-xr-xr-x.   4 root root 4096 Jan 29 12:09 boot
drwxr-xr-x.  13 root root  133 Mar 16 18:03 data
drwxr-xr-x.  20 root root 3180 Apr 17 22:54 dev
drwxr-xr-x.  97 root root 8192 Apr 21 15:39 etc
drwxr-xr-x.   2 root root    6 Jun 10  2014 home
lrwxrwxrwx.   1 root root    7 Sep  1  2015 lib -> usr/lib
lrwxrwxrwx.   1 root root    9 Sep  1  2015 lib64 -> usr/lib64
drwxr-xr-x.   2 root root    6 Jun 10  2014 media
drwxr-xr-x.   4 root root   29 Sep  1  2015 mnt
drwxr-xr-x.   2 root root    6 Jun 10  2014 opt
dr-xr-xr-x. 260 root root    0 Apr 17 22:54 proc
dr-xr-x---.  29 root root 4096 Apr 25 19:29 root
drwxr-xr-x.  24 root root  680 Apr 18 00:49 run
lrwxrwxrwx.   1 root root    8 Sep  1  2015 sbin -> usr/sbin
drwxr-xr-x.   2 root root    6 Jun 10  2014 srv
dr-xr-xr-x.  13 root root    0 Apr 17 22:54 sys
drwxrwxrwt.  37 root root 4096 Apr 25 19:18 tmp
drwxr-xr-x.  13 root root 4096 Sep  1  2015 usr
drwxr-xr-x.  21 root root 4096 Apr 17 22:54 var
-rw-r--r--.   1 root root    5 Sep  7  2015 zookeeper_server.pid
```
1. 模式mode - 上面的l/-/d之类 - stat.st_mode
> type(4) - suid(u,1) 0- sgid(g,1) - sticky(s,1) - user-perm(user,3) - group-perm(group,3) - other-perm(other,3)
2. 链接数 - 上面第一列数字 - stat.st_nlink
3. 文件所有者 - 上面的root - stat.st_uid
4. 组 - 上面的root - stat.st_gid
5. 大小 - 第二列数字 - stat.st_size（也可以自行计算）
6. 最后修改时间 - stat.st_mtime
7. 文件名 - dir entry from parent dir file

```c
struct stat {
    dev_t     st_dev;     /* ID of device containing file */
    ino_t     st_ino;     /* inode number */
    mode_t    st_mode;    /* protection */
    nlink_t   st_nlink;   /* number of hard links */
    uid_t     st_uid;     /* user ID of owner */
    gid_t     st_gid;     /* group ID of owner */
    dev_t     st_rdev;    /* device ID (if special file) */
    off_t     st_size;    /* total size, in bytes */
    blksize_t st_blksize; /* blocksize for file system I/O */
    blkcnt_t  st_blocks;  /* number of 512B blocks allocated */
    time_t    st_atime;   /* time of last access */
    time_t    st_mtime;   /* time of last modification */
    time_t    st_ctime;   /* time of last status change */
};
```

### file type
```shell
S_IF*：

S_IFMT
       Type of file.  // 0170000，也即 00000 11110000 00000000， 过滤出前四位，
S_IFBLK
       Block special.  // 0100000，也即 00000 10000000 00000000，第1位
S_IFCHR
       Character special.  // 0040000，也即 00000 01000000 00000000，第2位
S_IFIFO
       FIFO special.  // 0060000，也即 00000 01100000 00000000，2、3位
S_IFREG
       Regular.  // 0020000，第3位
S_IFDIR
       Directory.  // 0010000，第4位
S_IFLNK
       Symbolic link.  // 0120000，1、3位
S_IFSOCK
       Socket.  // 0140000，1、2位

对应的宏，S_IS*，类似：
#define S_ISDIR(m) (((m)&(0170000)) == (0040000))      
#define S_ISFIFO
#define S_ISCHR
#define S_ISBLK
#define S_ISREG
...
```

### file mode bits
```shell
S_IRWXU
      Read, write, execute/search by owner.
S_IRUSR
      Read permission, owner.
S_IWUSR
      Write permission, owner.
S_IXUSR
      Execute/search permission, owner.
S_IRWXG
      Read, write, execute/search by group.
S_IRGRP
      Read permission, group.
S_IWGRP
      Write permission, group.
S_IXGRP
      Execute/search permission, group.
S_IRWXO
      Read, write, execute/search by others.
S_IROTH
      Read permission, others.
S_IWOTH
      Write permission, others.
S_IXOTH
      Execute/search permission, others.
S_ISUID
      Set-user-ID on execution.
S_ISGID
      Set-group-ID on execution.
S_ISVTX
      On directories, restricted deletion flag.      

The bits defined by S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH, S_ISUID, S_ISGID,  and S_ISVTX shall be unique.
S_IRWXU is the bitwise-inclusive OR of S_IRUSR, S_IWUSR, and S_IXUSR.
S_IRWXG is the bitwise-inclusive OR of S_IRGRP, S_IWGRP, and S_IXGRP.
S_IRWXO is the bitwise-inclusive OR of S_IROTH, S_IWOTH, and S_IXOTH.      
```

### 获取username
* 通过/etc/passwd
> 但这只是一种鉴权方式，也有可能用NIS
* NIS

#### getpwuid
会先尝试从/etc/passwd，然后NIS。
```c
#include <sys/types.h>
#include <pwd.h>

struct passwd *getpwnam(const char *name);

struct passwd *getpwuid(uid_t uid);

int getpwnam_r(const char *name, struct passwd *pwd,
            char *buf, size_t buflen, struct passwd **result);

int getpwuid_r(uid_t uid, struct passwd *pwd,
            char *buf, size_t buflen, struct passwd **result);

// Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

getpwnam_r(), getpwuid_r():
    _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE
```

```
DESCRIPTION
The getpwnam() function returns a pointer to a structure containing the broken-out fields of the record in the password database (e.g., the local password file /etc/passwd, NIS, and LDAP) that matches the username name.

The getpwuid() function returns a pointer to a structure containing the broken-out fields of the record in the password database that matches the user ID uid.

The passwd structure is defined in <pwd.h> as follows:

    struct passwd {
        char   *pw_name;       /* username */
        char   *pw_passwd;     /* user password */
        uid_t   pw_uid;        /* user ID */
        gid_t   pw_gid;        /* group ID */
        char   *pw_gecos;      /* user information */
        char   *pw_dir;        /* home directory */
        char   *pw_shell;      /* shell program */
    };

See passwd(5) for more information about these fields.

The  getpwnam_r() and getpwuid_r() functions obtain the same information as getpwnam() and getpwuid(), but store the retrieved passwd structure in the space pointed to by pwd.  The string fields pointed to by the members of
the passwd structure are stored in the buffer buf of size buflen.  A pointer to the result (in case of success) or NULL (in case no entry was found or an error occurred) is stored in *result.

The call

    sysconf(_SC_GETPW_R_SIZE_MAX)

returns either -1, without changing errno, or an initial suggested size for buf.  (If this size is too small, the call fails with ERANGE, in which case the caller can retry with a larger buffer.)

RETURN VALUE
The getpwnam() and getpwuid() functions return a pointer to a passwd structure, or NULL if the matching entry is not found or an error occurs.  If an error occurs, errno is set appropriately.  If one wants  to  check  errno
after the call, it should be set to zero before the call.

The return value may point to a static area, and may be overwritten by subsequent calls to getpwent(3), getpwnam(), or getpwuid().  (Do not pass the returned pointer to free(3).)

On  success,  getpwnam_r() and getpwuid_r() return zero, and set *result to pwd.  If no matching password record was found, these functions return 0 and store NULL in *result.  In case of error, an error number is returned,
and NULL is stored in *result.

ERRORS
0 or ENOENT or ESRCH or EBADF or EPERM or ...
       The given name or uid was not found.

EINTR  A signal was caught.

EIO    I/O error.

EMFILE The maximum number (OPEN_MAX) of files was open already in the calling process.

ENFILE The maximum number of files was open already in the system.

ENOMEM Insufficient memory to allocate passwd structure.

ERANGE Insufficient buffer space supplied.
```

### 获取组名等

#### getgrgid
```c
#include <sys/types.h>
#include <grp.h>

struct group *getgrnam(const char *name);

struct group *getgrgid(gid_t gid);

int getgrnam_r(const char *name, struct group *grp,
          char *buf, size_t buflen, struct group **result);

int getgrgid_r(gid_t gid, struct group *grp,
          char *buf, size_t buflen, struct group **result);

// Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

getgrnam_r(), getgrgid_r():
    _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _BSD_SOURCE || _SVID_SOURCE || _POSIX_SOURCE
```

```
DESCRIPTION
The getgrnam() function returns a pointer to a structure containing the broken-out fields of the record in the group database (e.g., the local group file /etc/group, NIS, and LDAP) that matches the group name name.

The getgrgid() function returns a pointer to a structure containing the broken-out fields of the record in the group database that matches the group ID gid.

The group structure is defined in <grp.h> as follows:

    struct group {
        char   *gr_name;       /* group name */
        char   *gr_passwd;     /* group password */
        gid_t   gr_gid;        /* group ID */
        char  **gr_mem;        /* group members */
    };

For more information about the fields of this structure, see group(5).

The  getgrnam_r()  and getgrgid_r() functions obtain the same information as getgrnam() and getgrgid(), but store the retrieved group structure in the space pointed to by grp.  The string fields pointed to by the members of
the group structure are stored in the buffer buf of size buflen.  A pointer to the result (in case of success) or NULL (in case no entry was found or an error occurred) is stored in *result.

The call

    sysconf(_SC_GETGR_R_SIZE_MAX)

returns either -1, without changing errno, or an initial suggested size for buf.  (If this size is too small, the call fails with ERANGE, in which case the caller can retry with a larger buffer.)

RETURN VALUE
The getgrnam() and getgrgid() functions return a pointer to a group structure, or NULL if the matching entry is not found or an error occurs.  If an error occurs, errno is set appropriately.  If one  wants  to  check  errno
after the call, it should be set to zero before the call.

The return value may point to a static area, and may be overwritten by subsequent calls to getgrent(3), getgrgid(), or getgrnam().  (Do not pass the returned pointer to free(3).)

On  success, getgrnam_r() and getgrgid_r() return zero, and set *result to grp.  If no matching group record was found, these functions return 0 and store NULL in *result.  In case of error, an error number is returned, and
NULL is stored in *result.

ERRORS
0 or ENOENT or ESRCH or EBADF or EPERM or ...
       The given name or gid was not found.

EINTR  A signal was caught.

EIO    I/O error.

EMFILE The maximum number (OPEN_MAX) of files was open already in the calling process.

ENFILE The maximum number of files was open already in the system.

ENOMEM Insufficient memory to allocate group structure.

ERANGE Insufficient buffer space supplied.
```

# 三个特殊位
## set-user-ID（u）
加了该mode的文件，被任何用户执行都会有“文件所有者”的权限。
比如：
```shell
$ ls -l /etc/passwd /bin/passwd
-rwsr-xr-x. 1 root root 27832 Jun 10  2014 /bin/passwd
-rw-r--r--. 1 root root  1239 Jan 14 20:52 /etc/passwd
```

```c
#define S_ISUID 00400  // 三个特殊位的第一位
```

## set-group-ID（g）
同理，... “文件所属组”...

```c
#define S_ISGID 00200  // 三个特殊位的第二位
```

## sticky（s）

### 文件的sticky位
```
Setting the sticky bit on a file is pretty much useless, and it doesn’t do anything. On some of the older *nix flavors, a sticky bit enabled executable file will be loaded to the swap memory after 1st execution, which speeds up all subsequent execution. This is not true anymore.

From Wikipedia:

Currently, this behavior is only operative in HP-UX, NetBSD, and UnixWare.
Solaris appears to have abandoned this in 2005.[citation needed] The 4.4-Lite
release of BSD retained the old sticky bit behavior but it has been subsequently
dropped from OpenBSD (as of release 3.7) and FreeBSD (as of release 2.2.1);
it remains in NetBSD.

No version of Linux has ever supported the traditional behavior.
```

### 目录的sticky位
只有目录owner/文件owner（当然也包括root）才能重命名或删除文件。（否则的话只需要有dir的wx权限的用户就可以）。
典型使用场景是/tmp。

```shell
# 设置
chmod 1777 dir
或者
chmod +t dir

# 取消
chmod -t dir
```

# ls小结
...

# 设置和修改文件属性

## 文件类型
stat.st_mode mode_t

### 设置
创建时指定（如creat）

### （不能）修改
...

## 许可位与特殊属性位
stat.st_mode mode_t

### 设置
创建时（如creat的参数）

### 修改
`chmod`
```c
#include <sys/stat.h>

int chmod(const char *path, mode_t mode);
int fchmod(int fd, mode_t mode);

// Feature Test Macro Requirements for glibc (see feature_test_macros(7)):


fchmod():
    _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED
    || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L

// 示例：
chmod("/tmp/myfile", 04764);
chmod("/tmp/myfile", S_ISUID|S_IRWXU|S_IRGRP|S_IWGRP|S_IROTH);

```

## 链接数

### 设置（应该是增加）
`link`

### 修改（应该是减少）
`unlink`

## 文件owner user和owner group
stat.st_uid, stat.st_gid

### 设置
创建时根据当前uid、gid、umask生成

### 修改
`chown`
chown和chgrp命令都是用同一个系统调用（不同参数）。 -1表示不变。

```c
#include <unistd.h>

int chown(const char *path, uid_t owner, gid_t group);
int fchown(int fd, uid_t owner, gid_t group);
int lchown(const char *path, uid_t owner, gid_t group);

// Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

fchown(), lchown():
    _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED
    || /* Since glibc 2.12: */ _POSIX_C_SOURCE >= 200809L
```

## 文件大小


## 时间

三个时间
* mtime
> 最后修改时间
* atime
> 最后访问时间
* ctime
> 最后属性修改时间

### 设置
... 自然是创建时

### 修改
`utime`
接口限制： 会同时修改 mtime和atime，符合业务场景。
touch命令做的事情即为...

```c
#include <sys/types.h>
#include <utime.h>

int utime(const char *filename, const struct utimbuf *times);

#include <sys/time.h>

int utimes(const char *filename, const struct timeval times[2]);
```

```
DESCRIPTION
       The utime() system call changes the access and modification times of the inode specified by filename to the actime and modtime fields of times respectively.

       If times is NULL, then the access and modification times of the file are set to the current time.

       Changing timestamps is permitted when: either the process has appropriate privileges, or the effective user ID equals the user ID of the file, or times is NULL and the process has write permission for the file.

       The utimbuf structure is:

           struct utimbuf {
               time_t actime;       /* access time */
               time_t modtime;      /* modification time */
           };

       The utime() system call allows specification of timestamps with a resolution of 1 second.

       The utimes() system call is similar, but the times argument refers to an array rather than a structure.  The elements of this array are timeval structures, which allow a precision of 1 microsecond for specifying timestamps.
       The timeval structure is:

           struct timeval {
               long tv_sec;        /* seconds */
               long tv_usec;       /* microseconds */
           };

       times[0] specifies the new access time, and times[1] specifies the new modification time.  If times is NULL, then analogously to utime(), the access and modification times of the file are set to the current time.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Search permission is denied for one of the directories in the path prefix of path (see also path_resolution(7)).

       EACCES times is NULL, the caller's effective user ID does not match the owner of the file, the caller does not have write access to the file, and the caller is not privileged (Linux: does not have either  the  CAP_DAC_OVER‐
              RIDE or the CAP_FOWNER capability).

       ENOENT filename does not exist.

       EPERM  times is not NULL, the caller's effective UID does not match the owner of the file, and the caller is not privileged (Linux: does not have the CAP_FOWNER capability).

       EROFS  path resides on a read-only file system.

```

## 文件名

### 设置
创建时指定，creat

### 修改
`rename`

```c
#include <stdio.h>

int rename(const char *oldpath, const char *newpath);
```


# 问题

## 在struct dirent中，数组d_name[]的长度在有的系统上是1，有的系统是255，实际长度是多少？为什么会不同？为什么不定义成char\* ？

**通过struct后加上一段数据的方式来实现"动态数组"**
> 需要“动态”的数组应当是最后一个字段，长度可以是[1]或[0]
1. 根据需要的长度确定要开辟的空间长度（struct长度 + len + 1），+1的目的应该是方便print（\0结尾）。 下面代码中的 [1]应该也是类似目的，这是就不用+1了
2. malloc，然后转为 struct xx*

```c
#define _D_NAME_MAX 255  
struct  dirent {  
        __ulong64_t     d_offset;       /* real off after this entry */  
        ino_t           d_ino;          /* inode number of entry */  
        ushort_t        d_reclen;       /* length of this record */  
        ushort_t        d_namlen;       /* length of string in d_name */  
        char            d_name[_D_NAME_MAX+1];   

};  
/* sunOS */  
typedef struct dirent {  
        ino_t           d_ino;          /* &quot;inode number&quot; of entry */  
        off_t           d_off;          /* offset of disk directory entry */  
        unsigned short  d_reclen;       /* length of this record */  
        char            d_name[1];      /* name of file */  
} dirent_t;  
```


```c
struct dirent  
{  
   int len;  
   char a[0];  
};  

struct dirent *fun(char *str, int len)  
{  
   struct dirent* n = (struct dirent*)malloc(len +1 + sizeof(struct dirent));  
   if (!n)  
      return NULL;  
   n->len = len;  
   memcpy(n->a, str, len);  
   return n;  
}  
```

**这里对[0]的数组做 n->a 操作真有点tricky**


## 文件权限077对owner是否有影响
```shell
[yonka@localhost]/tmp% ls -l tt
-rw-r--r--. 1 yonka yonka 0 Apr 26 15:09 tt
[yonka@localhost]/tmp% chmod 007 tt
[yonka@localhost]/tmp% ls -l tt
-------rwx. 1 yonka yonka 0 Apr 26 15:09 tt
[yonka@localhost]/tmp% ./tt
zsh: permission denied: ./tt
[yonka@localhost]/tmp% cat tt
cat: tt: Permission denied
[yonka@localhost]/tmp% echo 213 > tt
zsh: permission denied: tt
[yonka@localhost]/tmp% exit

# root @ localhost in /tmp [16:06:05] tty:pts/1 L:1 N:190
$ cat tt
```
从上面可以看到，有影响，但不影响root。
估计实现是类似：
```
if user != root:
  if not has_perm(file.mode, user, perm):
    // 而没有 file.owner == user 的判断
    return_error()
```

## 是否允许相同uid的用户
```shell
# root @ localhost in /tmp [16:14:08] tty:pts/1 L:1 N:194
$ su vivian
[yonka@localhost]/tmp% whoami
yonka
[yonka@localhost]/tmp% id
uid=1000(yonka) gid=1000(yonka) groups=1000(yonka) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
[yonka@localhost]/tmp% echo $HOME
/home/vivian
[yonka@localhost]/tmp% exit

# root @ localhost in /tmp [16:14:46] tty:pts/1 L:1 N:195
$ su yonka
[yonka@localhost]/tmp% whoami
yonka
[yonka@localhost]/tmp% id
uid=1000(yonka) gid=1000(yonka) groups=1000(yonka) context=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
[yonka@localhost]/tmp% echo $HOME
/home/yonka
[yonka@localhost]/tmp% tail -n 2 /etc/passwd
yonka:x:1000:1000::/home/yonka:/bin/zsh
vivian:x:1000:1000::/home/vivian:/bin/zsh
```

直接用syscall取出来的信息如下：
```
pwd from uid 1000:
pw_name: yonka, pw_passwd: x, pw_uid: 1000, pw_gid: 1000, pw_gecos: , pw_dir: /home/yonka, pw_shell: /bin/zsh
pwd from uname yonka:
pw_name: yonka, pw_passwd: x, pw_uid: 1000, pw_gid: 1000, pw_gecos: , pw_dir: /home/yonka, pw_shell: /bin/zsh
pwd from uname vivian:
pw_name: vivian, pw_passwd: x, pw_uid: 1000, pw_gid: 1000, pw_gecos: , pw_dir: /home/vivian, pw_shell: /bin/zsh
```

从上面看到，是允许的，但是没有意义，id命令的实现可能是根据当前uid再去取passwd信息，而HOME等可能是su vivian时设置的，此时是用getpwnam来获取passwd信息。


## 目录等的setuid和setgid
```
Recall that the setuid and setgid bits were invented for a completely different purpose: causing an executable to run with its owner's uid or gid, rather than the uid or gid of the user running the file. Any other usage is just an extra feature.

These bits have no function on ordinary files that aren't executable. (And also shell scripts on some distros, due to security issues.) Originally, they also had no function for directories. Obviously somebody decided it would be cool to take the unused setgid on directories and use it to enforce consistency of group ownership. After all, if you're playing with group ownership, it's because more than one person is working with the file, and it probably makes sense for all the files in a given directory to belong to the same group, no matter who created them. Hassles due to somebody forgetting to run newgrp are eliminated.

So, why not implement the same feature for setuid and the file uid? Well, uid is much more basic than gid. If you implement this, often a file will not belong to the user who created it! Presumably the user can still modify the file (assuming the umask is something sane), but they can't change the permission bits. Hard to see the utility of that.
```
**上面提到可执行的普通文件以外的文件的setuid和setgid是无意义的，即使有效，也是副作用**
