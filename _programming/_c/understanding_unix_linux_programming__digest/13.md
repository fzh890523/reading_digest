
# 软件控制

# 许可证控制简史

# 一个非计算机系统实例： 轿车管理系统

## ongoingCS方式管理轿车

# 许可证管理

## 许可证服务系统：做些什么

## 许可证服务器系统：如何工作

## 一个通信系统的例子

# 数据报socket

## 相关系统调用

### recvfrom

签名
```c
#include <sys/types.h>
#include <sys/socket.h>

ssize_t recv(int sockfd, void *buf, size_t len, int flags);

ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                 struct sockaddr *src_addr, socklen_t *addrlen);

ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
```

描述
```
DESCRIPTION
       The recvfrom() and recvmsg() calls are used to receive messages from a socket, and may be used to receive data on a socket whether or not it is connection-oriented.

       If  src_addr  is not NULL, and the underlying protocol provides the source address, this source address is filled in.  When src_addr is NULL, nothing is filled in; in this case, addrlen is not used, and should also be NULL.
       The argument addrlen is a value-result argument, which the caller should initialize before the call to the size of the buffer associated with src_addr, and modified on return to  indicate  the  actual  size  of  the  source
       address.  The returned address is truncated if the buffer provided is too small; in this case, addrlen will return a value greater than was supplied to the call.

       The recv() call is normally used only on a connected socket (see connect(2)) and is identical to recvfrom() with a NULL src_addr argument.

       All  three  routines  return the length of the message on successful completion.  If a message is too long to fit in the supplied buffer, excess bytes may be discarded depending on the type of socket the message is received
       from.

       If no messages are available at the socket, the receive calls wait for a message to arrive, unless the socket is nonblocking (see fcntl(2)), in which case the value -1 is returned and the external variable errno is  set  to
       EAGAIN or EWOULDBLOCK.  The receive calls normally return any data available, up to the requested amount, rather than waiting for receipt of the full amount requested.

       The select(2) or poll(2) call may be used to determine when more data arrives.
		...
RETURN VALUE
       These calls return the number of bytes received, or -1 if an error occurred.  In the event of an error, errno is set to indicate the error.  The return value will be 0 when the peer has performed an orderly shutdown.

ERRORS
       These are some standard errors generated by the socket layer.  Additional errors may be generated and returned from the underlying protocol modules; see their manual pages.

       EAGAIN or EWOULDBLOCK
              The  socket  is  marked nonblocking and the receive operation would block, or a receive timeout had been set and the timeout expired before data was received.  POSIX.1-2001 allows either error to be returned for this
              case, and does not require these constants to have the same value, so a portable application should check for both possibilities.

       EBADF  The argument sockfd is an invalid descriptor.

       ECONNREFUSED
              A remote host refused to allow the network connection (typically because it is not running the requested service).

       EFAULT The receive buffer pointer(s) point outside the process's address space.

       EINTR  The receive was interrupted by delivery of a signal before any data were available; see signal(7).

       EINVAL Invalid argument passed.

       ENOMEM Could not allocate memory for recvmsg().

       ENOTCONN
              The socket is associated with a connection-oriented protocol and has not been connected (see connect(2) and accept(2)).

       ENOTSOCK
              The argument sockfd does not refer to a socket.
```

### sendto

原型
```c
#include <sys/types.h>
#include <sys/socket.h>

ssize_t send(int sockfd, const void *buf, size_t len, int flags);

ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
              const struct sockaddr *dest_addr, socklen_t addrlen);

ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
```

描述
```
DESCRIPTION
       The system calls send(), sendto(), and sendmsg() are used to transmit a message to another socket.

       The  send()  call  may  be used only when the socket is in a connected state (so that the intended recipient is known).  The only difference between send() and write(2) is the presence of flags.  With a zero flags argument,
       send() is equivalent to write(2).  Also, the following call

           send(sockfd, buf, len, flags);

       is equivalent to

           sendto(sockfd, buf, len, flags, NULL, 0);

       The argument sockfd is the file descriptor of the sending socket.

       If sendto() is used on a connection-mode (SOCK_STREAM, SOCK_SEQPACKET) socket, the arguments dest_addr and addrlen are ignored (and the error EISCONN may be returned when they are not NULL and 0), and the error ENOTCONN  is
       returned  when  the  socket  was not actually connected.  Otherwise, the address of the target is given by dest_addr with addrlen specifying its size.  For sendmsg(), the address of the target is given by msg.msg_name, with
       msg.msg_namelen specifying its size.

       For send() and sendto(), the message is found in buf and has length len.  For sendmsg(), the message is pointed to by the elements of the array msg.msg_iov.  The sendmsg() call also allows sending ancillary data (also known
       as control information).

       If the message is too long to pass atomically through the underlying protocol, the error EMSGSIZE is returned, and the message is not transmitted.

       No indication of failure to deliver is implicit in a send().  Locally detected errors are indicated by a return value of -1.

       When the message does not fit into the send buffer of the socket, send() normally blocks, unless the socket has been placed in nonblocking I/O mode.  In nonblocking mode it would fail with the error EAGAIN or EWOULDBLOCK in
       this case.  The select(2) call may be used to determine when it is possible to send more data.
		...
RETURN VALUE
       On success, these calls return the number of characters sent.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       These are some standard errors generated by the socket layer.  Additional errors may be generated and returned from the underlying protocol modules; see their respective manual pages.

       EACCES (For UNIX domain sockets, which are identified by pathname) Write permission is denied on the destination socket file, or search permission is denied for one of the directories the  path  prefix.   (See  path_resolu‐
              tion(7).)

              (For UDP sockets) An attempt was made to send to a network/broadcast address as though it was a unicast address.

       EAGAIN or EWOULDBLOCK
              The  socket  is  marked  nonblocking and the requested operation would block.  POSIX.1-2001 allows either error to be returned for this case, and does not require these constants to have the same value, so a portable
              application should check for both possibilities.

       EBADF  An invalid descriptor was specified.

       ECONNRESET
              Connection reset by peer.

       EDESTADDRREQ
              The socket is not connection-mode, and no peer address is set.

       EFAULT An invalid user space address was specified for an argument.

       EINTR  A signal occurred before any data was transmitted; see signal(7).

       EINVAL Invalid argument passed.

       EISCONN
              The connection-mode socket was connected already but a recipient was specified.  (Now either this error is returned, or the recipient specification is ignored.)

       EMSGSIZE
              The socket type requires that message be sent atomically, and the size of the message to be sent made this impossible.

       ENOBUFS
              The output queue for a network interface was full.  This generally indicates that the interface has stopped sending, but may be caused by transient congestion.  (Normally, this does not occur in Linux.   Packets  are
              just silently dropped when a device queue overflows.)

       ENOMEM No memory available.

       ENOTCONN
              The socket is not connected, and no target has been given.

       ENOTSOCK
              The argument sockfd is not a socket.

       EOPNOTSUPP
              Some bit in the flags argument is inappropriate for the socket type.

       EPIPE  The local end has been shut down on a connection oriented socket.  In this case the process will also receive a SIGPIPE unless MSG_NOSIGNAL is set.
```

## 流和数据报的比较

* 共同点
	* (c/s) 都需要socket
	* (s) 都需要bind，bind时经常都需要通过一系列操作得到合适的地址信息
	* (c/s) 读写操作接近（read/write 和 recvfrom/sendto）
* 不同点
	* (c) DGRAM不需要connect；STREAM需要
	* (s) DGRAM不需要listen；STREAM需要
	* (s) DGRAM直接在server socket上读写而STREAM在accept到的socket上读写
	* (s) DGRAM可能在socket上读到来自不同addr的消息； 而STREAM的socket有特定remote endpoint只会读到来自特定addr的消息
	> client不会，因为client的DGRAM socket是指定了remote
	> addr的，有一个local-remote的pair
	* (s) 类似的，DGRAM在send的时候需要指明send给那个addr；而STREAM本身就有conn-endpoints不需要再指明
	> 同样，client也不需要，因为client...

## 数据报编程

## sendto和recvfrom小结

### read/write VS recvfrom/sendto
对于服务端： 如果不需要应答（不需要获取remote addr信息）的话，可以用read； 但没法write，因为需要指定remote。
对于客户端： 因为remote是确定的，所以可以read/write。

## 数据报应答

## 数据报小结


# 许可证服务器版本1.0

## client版本1

## server版本1

## 测试版本1

## 进一步的工作


# 处理现实的问题

## 处理client崩溃

## 处理server崩溃

## 测试版本2


# 分布式许可证服务器


# unix域socket

## 文件名作为socket地址


### sockaddr地址类型
* sockaddr_in - AF_INET
> sin_addr = addr; - 字符串，经常会从hostent.h_addr中copy，如`bcopy((void *)hp->h_addr, (void *)&addrp->sin_addr, hp->h_length)`
> sin_port = port; - int
> sin_family = AF_INET;
* sockaddr_un - AF_UNIX
> sun_family = AF_UNIX; 
> sun_path = sockname; - sockname为文件path字符串

## 使用unix域socket编程
参见： [logfiled](code/13/logfiled.c) 和 [logfilec](code/13/logfilec.c)

# socket和服务器

# 小结
