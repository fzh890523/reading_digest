第9章 进程关系

#INDEX

* [登录时的进程](#登录时的进程)
	* [终端登录](##终端登录)
	* [网络登录](##网络登录)
* [进程相关](#进程相关)
	* [进程组](##进程组)
	* [会话](##会话)
	* [控制终端](##控制终端)
	* [实现](##实现)
* [典型场景](#典型场景)
	* [作业控制](##作业控制)
	* [shell执行程序](##shell执行程序)
	* [孤儿进程组](##孤儿进程组)


#进程相关

##进程组

###相关函数
* pid_t getpgrp(void);
* pid_t getpgid(pid_t pid);  // 传入pid为0时等价于 getpgrp
* int setpgid(pid_t pid, pid_t pgid);

###进程组产生


##会话
> 概念： 一个或多个进程组的集合

**会话首进程session leader**
> 创建该会话的进程，一定是一个进程组的组长进程。 下面简称SL。

**sid**
>会话id，一般实现是SL的pid

###会话相关函数
* pid_t setsid(void)
* pid_t getsid(pid_t pid)

###会话产生
**方式**： 通过 setsid 函数

**前提**： 调该函数的进程不是进程组的组长（那么也不会是SL）。 否则会报错。

**执行细节**：

* 该进程成为新会话的SL（此时该进程是新会话中唯一一个进程），SID为该进程PID
* 该进程成为新进程组GL（...），GID为该进程PID
* 如果该进程原来所在会话有控制终端的话，此时该联系被切断（也即不继承控制终端）

**进程组长如何成为新会话首进程**

前面提到，GL调setsid会报错，那么如果有场景GL要成为新会话SL该怎么办呢？

* fork一个子进程（gid为父进程PID）继续执行； 父进程退出
* 子进程调setsid（此时子进程不是GL身份可以调...）


##控制终端
