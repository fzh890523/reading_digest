
# 屏幕编程: curses库

## curses介绍

### curses基本函数
| 函数名 | 简介     |
| :------------- | :------------- |
| initscr       | 初始化curses库和tty       |
| endwin       |  关闭curses并重置tty      |
| refresh       | 使屏幕按意图显示（#yonka# 应该是使修改生效（显示在屏幕））       |
| move       | 移动光标到屏幕的(r,c)位置       |
| addstr       | 在当前位置画字符串s       |
| addch       | 在当前位置画字符c       |
| clear       | 清屏       |
| standout       |  启动standout模式（一般使屏幕反色）      |
| standend       |  关闭standout模式      |

## curses internal

### 虚拟屏幕 - 屏幕缓存
addstr会写入到屏幕缓存，refresh时才会真正描绘（输出）到真实屏幕 - `减小数据流量和绘制次数`
> refresh会比较“发生的变化”，然后只发送差异部分

# 时间编程： sleep
sleep+运动

问题：
sleep单位是秒而且是int，粒度太粗。 要使得运动平滑，需要更细粒度的sleep。
如： usleep、nanosleep
```
NAME
       usleep - suspend execution for microsecond intervals

SYNOPSIS
       #include <unistd.h>

       int usleep(useconds_t usec);

   Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

       usleep():
           Since glibc 2.12:
               _BSD_SOURCE ||
                   (_XOPEN_SOURCE >= 500 ||
                       _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED) &&
                   !(_POSIX_C_SOURCE >= 200809L || _XOPEN_SOURCE >= 700)
           Before glibc 2.12:
               _BSD_SOURCE || _XOPEN_SOURCE >= 500 || _XOPEN_SOURCE && _XOPEN_SOURCE_EXTENDED

DESCRIPTION
       The usleep() function suspends execution of the calling thread for (at least) usec microseconds.  The sleep may be lengthened slightly by any system activity or by the time spent processing the call or by the granularity of
       system timers.

RETURN VALUE
       The usleep() function returns 0 on success.  On error, -1 is returned, with errno set to indicate the cause of the error.

ERRORS
       EINTR  Interrupted by a signal; see signal(7).

       EINVAL usec is not smaller than 1000000.  (On systems where that is considered an error.)

CONFORMING TO
       4.3BSD, POSIX.1-2001.  POSIX.1-2001 declares this function obsolete; use nanosleep(2) instead.  POSIX.1-2008 removes the specification of usleep().

       On the original BSD implementation, and in glibc before version 2.2.2, the return type of this function is void.  The POSIX version returns int, and this is also the prototype used since glibc 2.2.2.

       Only the EINVAL error return is documented by SUSv2 and POSIX.1-2001.

NOTES
       The type useconds_t is an unsigned integer type capable of holding integers in the range [0,1000000].  Programs will be more portable if they never mention this type explicitly.  Use

           #include <unistd.h>
           ...
               unsigned int usecs;
           ...
               usleep(usecs);

       The interaction of this function with the SIGALRM signal, and with other timer functions such as alarm(2), sleep(3),  nanosleep(2),  setitimer(2),  timer_create(2),  timer_delete(2),  timer_getoverrun(2),  timer_gettime(2),
       timer_settime(2), ualarm(3) is unspecified.
```

# 时钟编程1：alarms

## 添加时延：sleep
```
NAME
       sleep - sleep for the specified number of seconds

SYNOPSIS
       #include <unistd.h>

       unsigned int sleep(unsigned int seconds);

DESCRIPTION
       sleep() makes the calling thread sleep until seconds seconds have elapsed or a signal arrives which is not ignored.

RETURN VALUE
       Zero if the requested time has elapsed, or the number of seconds left to sleep, if the call was interrupted by a signal handler.

CONFORMING TO
       POSIX.1-2001.

BUGS
       sleep() may be implemented using SIGALRM; mixing calls to alarm(2) and sleep() is a bad idea.

       Using longjmp(3) from a signal handler or modifying the handling of SIGALRM while sleeping will cause undefined results.

SEE ALSO
       alarm(2), nanosleep(2), signal(2), signal(7)
```

## sleep是如何工作的：使用unix alarms
`man 3 sleep`： sleep是lib function
上面可以看到，sleep的实现可能是SIGALRM，建议不要混用sleep和alarm。
`man 2 alarm`： alarm是syscall

工作过程：
1. signal(SIGALRM, handler)
2. alarm(n)  // 让内核在n秒后发出一个SIGALRM信号给进程
3. pause()  // 挂起进程直至任意信号到达（注意，不止是SIGALRM）

> 可以看到，问题在于pause的效果和预期的`收到SIGALRM时“醒来”`不符。 所以实际需要做更多... = =


### unix syscall alarm
```
NAME
       alarm - set an alarm clock for delivery of a signal

SYNOPSIS
       #include <unistd.h>

       unsigned int alarm(unsigned int seconds);

DESCRIPTION
       alarm() arranges for a SIGALRM signal to be delivered to the calling process in seconds seconds.

       If seconds is zero, any pending alarm is canceled.

       In any event any previously set alarm() is canceled.

RETURN VALUE
       alarm() returns the number of seconds remaining until any previously scheduled alarm was due to be delivered, or zero if there was no previously scheduled alarm.

CONFORMING TO
       SVr4, POSIX.1-2001, 4.3BSD.

NOTES
       alarm() and setitimer(2) share the same timer; calls to one will interfere with use of the other.

       sleep(3) may be implemented using SIGALRM; mixing calls to alarm() and sleep(3) is a bad idea.

       Scheduling delays can, as ever, cause the execution of the process to be delayed by an arbitrary amount of time.

SEE ALSO
       gettimeofday(2), pause(2), select(2), setitimer(2), sigaction(2), signal(2), sleep(3), time(7)
```


## 调度将要发生的动作
alarm的另一个用途。 在SIGALRM的handler里指定希望在确定的“将来”做的事情。
但要注意信号处理和正常执行流可能是并发的，所以要注意并发安全。

# 时钟编程2： 间隔计时器

```
NAME
       getitimer, setitimer - get or set value of an interval timer

SYNOPSIS
       #include <sys/time.h>

       int getitimer(int which, struct itimerval *curr_value);
       int setitimer(int which, const struct itimerval *new_value,
                     struct itimerval *old_value);

DESCRIPTION
       The system provides each process with three interval timers, each decrementing in a distinct time domain.  When any timer expires, a signal is sent to the process, and the timer (potentially) restarts.

       ITIMER_REAL    decrements in real time, and delivers SIGALRM upon expiration.

       ITIMER_VIRTUAL decrements only when the process is executing, and delivers SIGVTALRM upon expiration.

       ITIMER_PROF    decrements  both  when  the process executes and when the system is executing on behalf of the process.  Coupled with ITIMER_VIRTUAL, this timer is usually used to profile the time spent by the application in
                      user and kernel space.  SIGPROF is delivered upon expiration.

       Timer values are defined by the following structures:

           struct itimerval {
               struct timeval it_interval; /* next value */
               struct timeval it_value;    /* current value */
           };

           struct timeval {
               time_t      tv_sec;         /* seconds */
               suseconds_t tv_usec;        /* microseconds */
           };

       The function getitimer() fills the structure pointed to by curr_value with the current setting for the timer specified by which (one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF).  The  element  it_value  is  set  to  the
       amount of time remaining on the timer, or zero if the timer is disabled.  Similarly, it_interval is set to the reset value.

       The function setitimer() sets the specified timer to the value in new_value.  If old_value is non-NULL, the old value of the timer is stored there.

       Timers decrement from it_value to zero, generate a signal, and reset to it_interval.  A timer which is set to zero (it_value is zero or the timer expires and it_interval is zero) stops.

       Both tv_sec and tv_usec are significant in determining the duration of a timer.

       Timers  will  never  expire before the requested time, but may expire some (short) time afterward, which depends on the system timer resolution and on the system load; see time(7).  (But see BUGS below.)  Upon expiration, a
       signal will be generated and the timer reset.  If the timer expires while the process is active (always true for ITIMER_VIRTUAL) the signal will be delivered immediately when generated.  Otherwise the delivery will be  off‐
       set by a small time dependent on the system loading.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EFAULT new_value, old_value, or curr_value is not valid a pointer.

       EINVAL which is not one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF; or (since Linux 2.6.22) one of the tv_usec fields in the structure pointed to by new_value contains a value outside the range 0 to 999999.
```

## 添加精度更高的时延：使用usleep
... 见前面的manual

## 三种计时器：真实、进程和实用
* ITIMER_REAL
> 真实时间（包括user、sys等所有）
> 超时的话发送SIGALRM
* ITIMER_VIRTUAL
> 只对user进行计时
> 超时的话发送SIGVTALRM
* ITIMER_PROF
> 对application相关的耗时进行计时，包括user+syscall（估计是run+block吧，不包含ready）
> 超时的话发送SIGPROF


## 两种间隔：初始和重复
delay+interval，间隔计时器的两个参数： it_value, it_interval。类型都是struct timeval。
```c
struct itimerval {
    struct timeval it_interval; /* next value */
    struct timeval it_value;    /* current value */
};

struct timeval {
    time_t      tv_sec;         /* seconds */
    suseconds_t tv_usec;        /* microseconds */
};
```

## 用间隔计时器编程
见 [ticker_demo.c](code/07/ticker_demo.c)

## 计算机有几个时钟
> 一个内核时钟。
>> 每当内核收到系统时钟脉冲，会遍历所有的间隔计时器，使每个计时器减去一个时钟单位。
>> 如果有计数器为0，则给该进程发去SIGALRM。
>> 如果计时器的it_interval已设置，则会复制该值到it_value，否则会关闭该计时器。

# 信号处理1： 使用signal

## 早期的信号处理机制
前面提到的处理信号三种方式...

`每次使用后需要做重置` 类似如下：
```c
void handler(int signum)
{
  // process signal
  signal(signum, handler);  // reset
  // other work
}
```


## 处理多个信号

### 捕鼠器的比喻 - 多个信号
原始的需要**重置**的信号处理机制类似捕鼠器： `捕鼠器捕获到老鼠后，即使处理的再快，也可能（在这个时间间隔里）有老鼠溜走`

### 几个问题场景
* handler每次使用后要被禁用吗？（捕鼠器模型）
* 如果SIGY消息再进程处理SIGX消息时到达会发生什么呢？
* 如果进程在处理SIGX时又来了一个SIGX会发生什么呢？又来第三个呢？
* 如果消息到来时，进程正在阻塞中（syscall，如getchar、read等），会如何呢？

## 测试多个信号

## 信号机制的其他弱电


# 信号处理2： sigaction

## 处理多个信号：sigaction

## 信号小结


# 防止数据损毁： data corruption

## 数据损毁的例子

## 临界区（critical sections）

## 阻塞信号：sigprocmask和sigsetops

## 重入代码：reentran code

## 视频游戏中的临界期

# kill：从另一个进程发送的信号


# 使用计时器和信号：视频游戏

## bouncd1d.c：在一条线上控制动画

## bounce2d.c：二维动画

## 完成游戏

# 输入信号：异步IO

## 使用异步IO

## 方法1：使用O_ASYNC

## 方法2：使用aio_read

## 弹球程序中需要异步读入吗

## 异步输入、视频游戏和操作系统


# 小结
