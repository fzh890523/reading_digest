
# 产品和服务

# 一个简单的比喻： 饮料机接口

## 4种类型的数据来源
* 磁盘文件
* 设备
> 和磁盘文件一样，用open连接，用read/write传递数据
* 管道
> 用pipe创建，用fork共享，用read/write传递数据
* sockets
> 用socket、listen、connect连接，用read/write传递数据

# bc：unix中使用的计算器

## 编写bc： pipe、fork、dup、exec

bc执行过程如下：
1. 创建两个管道
2. 创建子进程执行dc
3. 在新创建的进程中，重定向stdin和stdout到管道，然后 exec dc
4. 在父进程（bc）读取并分析用户的输入，（生成命令并且）将命令传给dc，然后从dc读取响应，并把响应传给用户

> 用两个管道来实现`双工`

## 对协同进程的讨论

bc 和 dc： 协同进程
类似C/S模型。

### strace查看bc和dc交互
`strace -f bash "echo 3 + 2 | bc -c"`
可以看到如下：
```shell
...
[pid 12857] ioctl(0, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0x7ffc10767640) = -1 ENOTTY (Inappropriate ioctl for device)
[pid 12857] read(0, "3 + 2\n", 8192)    = 6
[pid 12857] write(1, "@iK3:K2:+W@r\n", 13@iK3:K2:+W@r
) = 13
[pid 12857] read(0, "", 8192)           = 0
[pid 12857] ioctl(0, SNDCTL_TMR_TIMEBASE or SNDRV_TIMER_IOCTL_NEXT_DEVICE or TCGETS, 0x7ffc10767600) = -1 ENOTTY (Inappropriate ioctl for device)
[pid 12857] write(1, "@i\n", 3@i
...
```

## fdopen：让文件描述符像文件一样使用

通过fd的到*FILE，实际上是通过一系列系统调用获取file的各种信息赋给新的FILE

### 签名
```c
#include <stdio.h>

FILE *fopen(const char *path, const char *mode);

FILE *fdopen(int fd, const char *mode);

FILE *freopen(const char *path, const char *mode, FILE *stream);

// Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

// fdopen(): _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE
```

### 介绍
```
DESCRIPTION
       The fopen() function opens the file whose name is the string pointed to by path and associates a stream with it.

       The argument mode points to a string beginning with one of the following sequences (possibly followed by additional characters, as described below):

       r      Open text file for reading.  The stream is positioned at the beginning of the file.

       r+     Open for reading and writing.  The stream is positioned at the beginning of the file.

       w      Truncate file to zero length or create text file for writing.  The stream is positioned at the beginning of the file.

       w+     Open for reading and writing.  The file is created if it does not exist, otherwise it is truncated.  The stream is positioned at the beginning of the file.

       a      Open for appending (writing at end of file).  The file is created if it does not exist.  The stream is positioned at the end of the file.

       a+     Open  for reading and appending (writing at end of file).  The file is created if it does not exist.  The initial file position for reading is at the beginning of the file, but output is always appended to the end of
              the file.

       The mode string can also include the letter 'b' either as a last character or as a character between the characters in any of the two-character strings described above.  This is strictly for compatibility with C89  and  has
       no  effect;  the  'b'  is ignored on all POSIX conforming systems, including Linux.  (Other systems may treat text files and binary files differently, and adding the 'b' may be a good idea if you do I/O to a binary file and
       expect that your program may be ported to non-UNIX environments.)

       See NOTES below for details of glibc extensions for mode.

       Any created files will have mode S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH (0666), as modified by the process's umask value (see umask(2)).

       Reads and writes may be intermixed on read/write streams in any order.  Note that ANSI C requires that a file positioning function intervene between output and input, unless an input operation encounters  end-of-file.   (If
       this  condition  is  not  met,  then a read is allowed to return the result of writes other than the most recent.)  Therefore it is good practice (and indeed sometimes necessary under Linux) to put an fseek(3) or fgetpos(3)
       operation between write and read operations on such a stream.  This operation may be an apparent no-op (as in fseek(..., 0L, SEEK_CUR) called for its synchronizing side effect.

       Opening a file in append mode (a as the first character of mode) causes all subsequent write operations to this stream to occur at end-of-file, as if preceded the call:

           fseek(stream, 0, SEEK_END);

       The fdopen() function associates a stream with the existing file descriptor, fd.  The mode of the stream (one of the values "r", "r+", "w", "w+", "a", "a+") must be compatible with the mode of the file descriptor.  The file
       position indicator of the new stream is set to that belonging to fd, and the error and end-of-file indicators are cleared.  Modes "w" or "w+" do not cause truncation of the file.  The file descriptor is not dup'ed, and will
       be closed when the stream created by fdopen() is closed.  The result of applying fdopen() to a shared memory object is undefined.

       The freopen() function opens the file whose name is the string pointed to by path and associates the stream pointed to by stream with it.  The original stream (if it exists) is closed.  The mode argument is used just as  in
       the fopen() function.  The primary use of the freopen() function is to change the file associated with a standard text stream (stderr, stdin, or stdout).

RETURN VALUE
       Upon successful completion fopen(), fdopen() and freopen() return a FILE pointer.  Otherwise, NULL is returned and errno is set to indicate the error.

ERRORS
       EINVAL The mode provided to fopen(), fdopen(), or freopen() was invalid.

       The fopen(), fdopen() and freopen() functions may also fail and set errno for any of the errors specified for the routine malloc(3).

       The fopen() function may also fail and set errno for any of the errors specified for the routine open(2).

       The fdopen() function may also fail and set errno for any of the errors specified for the routine fcntl(2).

       The freopen() function may also fail and set errno for any of the errors specified for the routines open(2), fclose(3) and fflush(3).
```

### 实现
```c
#   define fdopen(fd, mode) _IO_new_fdopen (fd, mode)

_IO_FILE *
_IO_new_fdopen (int fd, const char *mode)
{
  int read_write;
  struct locked_FILE
  {
    struct _IO_FILE_plus fp;
#ifdef _IO_MTSAFE_IO
    _IO_lock_t lock;
#endif
    struct _IO_wide_data wd;
  } *new_f;
  int i;
  int use_mmap = 0;

  /* Decide whether we modify the offset of the file we attach to and seek to
     the end of file.  We only do this if the mode is 'a' and if the file
     descriptor did not have O_APPEND in its flags already.  */
  bool do_seek = false;

  switch (*mode)
    {
    case 'r':
      read_write = _IO_NO_WRITES;
      break;
    case 'w':
      read_write = _IO_NO_READS;
      break;
    case 'a':
      read_write = _IO_NO_READS|_IO_IS_APPENDING;
      break;
    default:
      MAYBE_SET_EINVAL;
      return NULL;
  }
  for (i = 1; i < 5; ++i)
    {
      switch (*++mode)
	{
	case '\0':
	  break;
	case '+':
	  read_write &= _IO_IS_APPENDING;
	  break;
	case 'm':
	  use_mmap = 1;
	  continue;
	case 'x':
	case 'b':
	default:
	  /* Ignore */
	  continue;
	}
      break;
    }
#ifdef F_GETFL
  int fd_flags = _IO_fcntl (fd, F_GETFL);
#ifndef O_ACCMODE
#define O_ACCMODE (O_RDONLY|O_WRONLY|O_RDWR)
#endif
  if (fd_flags == -1)
    return NULL;

  if (((fd_flags & O_ACCMODE) == O_RDONLY && !(read_write & _IO_NO_WRITES))
      || ((fd_flags & O_ACCMODE) == O_WRONLY && !(read_write & _IO_NO_READS)))
    {
      MAYBE_SET_EINVAL;
      return NULL;
    }

  /* The May 93 draft of P1003.4/D14.1 (redesignated as 1003.1b)
     [System Application Program Interface (API) Amendment 1:
     Realtime Extensions], Rationale B.8.3.3
     Open a Stream on a File Descriptor says:

	 Although not explicitly required by POSIX.1, a good
	 implementation of append ("a") mode would cause the
	 O_APPEND flag to be set.

     (Historical implementations [such as Solaris2] do a one-time
     seek in fdopen.)

     However, we do not turn O_APPEND off if the mode is "w" (even
     though that would seem consistent) because that would be more
     likely to break historical programs.
     */
  if ((read_write & _IO_IS_APPENDING) && !(fd_flags & O_APPEND))
    {
      do_seek = true;
#ifdef F_SETFL
      if (_IO_fcntl (fd, F_SETFL, fd_flags | O_APPEND) == -1)
#endif
	return NULL;
    }
#endif

  new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));
  if (new_f == NULL)
    return NULL;
#ifdef _IO_MTSAFE_IO
  new_f->fp.file._lock = &new_f->lock;
#endif
  _IO_no_init (&new_f->fp.file, 0, 0, &new_f->wd,
#ifdef _G_HAVE_MMAP
	       (use_mmap && (read_write & _IO_NO_WRITES))
	       ? &_IO_wfile_jumps_maybe_mmap :
#endif
	       &_IO_wfile_jumps);
  _IO_JUMPS (&new_f->fp) =
#ifdef _G_HAVE_MMAP
    (use_mmap && (read_write & _IO_NO_WRITES)) ? &_IO_file_jumps_maybe_mmap :
#endif
      &_IO_file_jumps;
  _IO_file_init (&new_f->fp);
#if  !_IO_UNIFIED_JUMPTABLES
  new_f->fp.vtable = NULL;
#endif
  /* We only need to record the fd because _IO_file_init will have unset the
     offset.  It is important to unset the cached offset because the real
     offset in the file could change between now and when the handle is
     activated and we would then mislead ftell into believing that we have a
     valid offset.  */
  new_f->fp.file._fileno = fd;
  new_f->fp.file._flags &= ~_IO_DELETE_DONT_CLOSE;

  _IO_mask_flags (&new_f->fp.file, read_write,
		  _IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);

  /* For append mode, set the file offset to the end of the file if we added
     O_APPEND to the file descriptor flags.  Don't update the offset cache
     though, since the file handle is not active.  */
  if (do_seek && ((read_write & (_IO_IS_APPENDING | _IO_NO_READS))
		  == (_IO_IS_APPENDING | _IO_NO_READS)))
    {
      _IO_off64_t new_pos = _IO_SYSSEEK (&new_f->fp.file, 0, _IO_seek_end);
      if (new_pos == _IO_pos_BAD && errno != ESPIPE)
	return NULL;
    }
  return &new_f->fp.file;
}
```

# popen：让进程看似文件
像操作文件一样操作一个（子）进程（的标准输入输出）。
原型里path可以是任意shell命令，mode可以是"r"或"w"，不能是"a"。
> 其实看glibc源码可以看到实现是调 `sh -c`
>> `_IO_execl ("/bin/sh", "sh", "-c", command, (char *) 0);`

## 系统调用

原型
```c
#include <stdio.h>

FILE *fopen(const char *path, const char *mode);

FILE *fdopen(int fd, const char *mode);

FILE *freopen(const char *path, const char *mode, FILE *stream);

// Feature Test Macro Requirements for glibc (see feature_test_macros(7)):

// fdopen(): _POSIX_C_SOURCE >= 1 || _XOPEN_SOURCE || _POSIX_SOURCE
```

介绍
```
DESCRIPTION
       The fopen() function opens the file whose name is the string pointed to by path and associates a stream with it.

       The argument mode points to a string beginning with one of the following sequences (possibly followed by additional characters, as described below):

       r      Open text file for reading.  The stream is positioned at the beginning of the file.

       r+     Open for reading and writing.  The stream is positioned at the beginning of the file.

       w      Truncate file to zero length or create text file for writing.  The stream is positioned at the beginning of the file.

       w+     Open for reading and writing.  The file is created if it does not exist, otherwise it is truncated.  The stream is positioned at the beginning of the file.

       a      Open for appending (writing at end of file).  The file is created if it does not exist.  The stream is positioned at the end of the file.

       a+     Open  for reading and appending (writing at end of file).  The file is created if it does not exist.  The initial file position for reading is at the beginning of the file, but output is always appended to the end of
              the file.

       The mode string can also include the letter 'b' either as a last character or as a character between the characters in any of the two-character strings described above.  This is strictly for compatibility with C89  and  has
       no  effect;  the  'b'  is ignored on all POSIX conforming systems, including Linux.  (Other systems may treat text files and binary files differently, and adding the 'b' may be a good idea if you do I/O to a binary file and
       expect that your program may be ported to non-UNIX environments.)

       See NOTES below for details of glibc extensions for mode.

       Any created files will have mode S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH (0666), as modified by the process's umask value (see umask(2)).

       Reads and writes may be intermixed on read/write streams in any order.  Note that ANSI C requires that a file positioning function intervene between output and input, unless an input operation encounters  end-of-file.   (If
       this  condition  is  not  met,  then a read is allowed to return the result of writes other than the most recent.)  Therefore it is good practice (and indeed sometimes necessary under Linux) to put an fseek(3) or fgetpos(3)
       operation between write and read operations on such a stream.  This operation may be an apparent no-op (as in fseek(..., 0L, SEEK_CUR) called for its synchronizing side effect.

       Opening a file in append mode (a as the first character of mode) causes all subsequent write operations to this stream to occur at end-of-file, as if preceded the call:

           fseek(stream, 0, SEEK_END);

       The fdopen() function associates a stream with the existing file descriptor, fd.  The mode of the stream (one of the values "r", "r+", "w", "w+", "a", "a+") must be compatible with the mode of the file descriptor.  The file
       position indicator of the new stream is set to that belonging to fd, and the error and end-of-file indicators are cleared.  Modes "w" or "w+" do not cause truncation of the file.  The file descriptor is not dup'ed, and will
       be closed when the stream created by fdopen() is closed.  The result of applying fdopen() to a shared memory object is undefined.

       The freopen() function opens the file whose name is the string pointed to by path and associates the stream pointed to by stream with it.  The original stream (if it exists) is closed.  The mode argument is used just as  in
       the fopen() function.  The primary use of the freopen() function is to change the file associated with a standard text stream (stderr, stdin, or stdout).

RETURN VALUE
       Upon successful completion fopen(), fdopen() and freopen() return a FILE pointer.  Otherwise, NULL is returned and errno is set to indicate the error.

ERRORS
       EINVAL The mode provided to fopen(), fdopen(), or freopen() was invalid.

       The fopen(), fdopen() and freopen() functions may also fail and set errno for any of the errors specified for the routine malloc(3).

       The fopen() function may also fail and set errno for any of the errors specified for the routine open(2).

       The fdopen() function may also fail and set errno for any of the errors specified for the routine fcntl(2).

       The freopen() function may also fail and set errno for any of the errors specified for the routines open(2), fclose(3) and fflush(3).
```

## popen的功能

完成读写后需要pclose，否则会成为僵尸进程。

## 实现popen：使用fdopen功能

`唯一能够运行任意shell命令的程序是shell本身，也即 /bin/sh`： `sh -c "command"`

1. pipe得到p
2. fork
3. 分叉
	* parent
		1. close(p[1-x])
		2. fp = fdopen(p[x])
		3. return fp
	* child
		1. close(p[x])  // x根据r/w而定，可能是0或1
		2. dup(p[1-x], 1/0)  // 根据r/w而定，是1或0
		3. close(p[1-x])

## 访问数据： 文件、API和服务器

# socket：与远端进程相连
**允许在不相关的（甚至不同主机上的）进程间创建类似管道的连接**

## 类比：电话报时...

重要的概念
* client、server
* hostname、port
> ...
* addr family
> 类似`底层通信层类型`的意思，不同的family对应不同的承载方式
> AF_XXX
* protocol
> 对应哪个应用层服务

## 时间、DAP和天气服务器

## 服务列表： 众所周知的端口
/etc/services

```shell
 root @ localhost:/tmp # cat /etc/services
# Network services, Internet style
#
# Note that it is presently the policy of IANA to assign a single well-known
# port number for both TCP and UDP; hence, officially ports have two entries
# even if the protocol doesn't support UDP operations.
#
# Updated from http://www.iana.org/assignments/port-numbers and other
# sources like http://www.freebsd.org/cgi/cvsweb.cgi/src/etc/services .
# New ports will be added on request if they have been officially assigned
# by IANA and used in the real-world or are needed by a debian package.
# If you need a huge list of used numbers please install the nmap package.
tcpmux          1/tcp                           # TCP port service multiplexer
echo            7/tcp
echo            7/udp
discard         9/tcp           sink null
discard         9/udp           sink null
systat          11/tcp          users
daytime         13/tcp
daytime         13/udp
netstat         15/tcp
qotd            17/tcp          quote
msp             18/tcp                          # message send protocol
...

#
# UNIX specific services
#
exec            512/tcp
biff            512/udp         comsat
login           513/tcp
who             513/udp         whod
shell           514/tcp         cmd             # no passwords used
syslog          514/udp
printer         515/tcp         spooler         # line printer spooler
...

#
# From ``Assigned Numbers'':
#
#> The Registered Ports are not controlled by the IANA and on most systems
#> can be used by ordinary user processes or programs executed by ordinary
#> users.
#
#> Ports are used in the TCP [45,106] to name the ends of logical
#> connections which carry long term conversations.  For the purpose of
#> providing services to unknown callers, a service contact port is
#> defined.  This list specifies the port used by the server process as its
#> contact port.  While the IANA can not control uses of these ports it
#> does register or list uses of these ports as a convienence to the
#> community.
#
socks           1080/tcp                        # socks proxy server
socks           1080/udp
proofd          1093/tcp
proofd          1093/udp
rootd           1094/tcp
rootd           1094/udp
openvpn         1194/tcp
openvpn         1194/udp
rmiregistry     1099/tcp                        # Java RMI Registry
...


#
# Datagram Delivery Protocol services
#
rtmp            1/ddp                   # Routing Table Maintenance Protocol
nbp             2/ddp                   # Name Binding Protocol
echo            4/ddp                   # AppleTalk Echo Protocol
zip             6/ddp                   # Zone Information Protocol

#=========================================================================
# The remaining port numbers are not as allocated by IANA.
#=========================================================================

# Kerberos (Project Athena/MIT) services
# Note that these are for Kerberos v4, and are unofficial.  Sites running
# v4 should uncomment these and comment out the v5 entries above.
#
kerberos4       750/udp         kerberos-iv kdc # Kerberos (server)
kerberos4       750/tcp         kerberos-iv kdc
kerberos-master 751/udp         kerberos_master # Kerberos authentication
kerberos-master 751/tcp
passwd-server   752/udp         passwd_server   # Kerberos passwd server
krb-prop        754/tcp         krb_prop krb5_prop hprop # Kerberos slave propagation
krbupdate       760/tcp         kreg            # Kerberos registration
swat            901/tcp                         # swat
kpop            1109/tcp                        # Pop with Kerberos
knetd           2053/tcp                        # Kerberos de-multiplexor
zephyr-srv      2102/udp                        # Zephyr server
zephyr-clt      2103/udp                        # Zephyr serv-hm connection
zephyr-hm       2104/udp                        # Zephyr hostmanager
eklogin         2105/tcp                        # Kerberos encrypted rlogin
# Hmmm. Are we using Kv4 or Kv5 now? Worrying.
# The following is probably Kerberos v5  --- ajt@debian.org (11/02/2000)
kx              2111/tcp                        # X over Kerberos
iprop           2121/tcp                        # incremental propagation
#
# Unofficial but necessary (for NetBSD) services
#
supfilesrv      871/tcp                         # SUP server
supfiledbg      1127/tcp                        # SUP debugging

#
# Services added for the Debian GNU/Linux distribution
#
linuxconf       98/tcp                          # LinuxConf
poppassd        106/tcp                         # Eudora
poppassd        106/udp
moira-db        775/tcp         moira_db        # Moira database
moira-update    777/tcp         moira_update    # Moira update protocol
moira-ureg      779/udp         moira_ureg      # Moira user registration
...
```

## socket相关系统调用

### socket

创建`通信的端点`

签名
```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
```

介绍
```
DESCRIPTION
       socket() creates an endpoint for communication and returns a descriptor.

       The domain argument specifies a communication domain; this selects the protocol family which will be used for communication.  These families are defined in <sys/socket.h>.  The currently understood formats include:

       Name                Purpose                          Man page
       AF_UNIX, AF_LOCAL   Local communication              unix(7)
       AF_INET             IPv4 Internet protocols          ip(7)
       AF_INET6            IPv6 Internet protocols          ipv6(7)
       AF_IPX              IPX - Novell protocols
       AF_NETLINK          Kernel user interface device     netlink(7)
       AF_X25              ITU-T X.25 / ISO-8208 protocol   x25(7)
       AF_AX25             Amateur radio AX.25 protocol
       AF_ATMPVC           Access to raw ATM PVCs
       AF_APPLETALK        Appletalk                        ddp(7)
       AF_PACKET           Low level packet interface       packet(7)

       The socket has the indicated type, which specifies the communication semantics.  Currently defined types are:

       SOCK_STREAM     Provides sequenced, reliable, two-way, connection-based byte streams.  An out-of-band data transmission mechanism may be supported.

       SOCK_DGRAM      Supports datagrams (connectionless, unreliable messages of a fixed maximum length).

       SOCK_SEQPACKET  Provides a sequenced, reliable, two-way connection-based data transmission path for datagrams of fixed maximum length; a consumer is required to read an entire packet with each input system call.

       SOCK_RAW        Provides raw network protocol access.

       SOCK_RDM        Provides a reliable datagram layer that does not guarantee ordering.

       SOCK_PACKET     Obsolete and should not be used in new programs; see packet(7).

       Some socket types may not be implemented by all protocol families; for example, SOCK_SEQPACKET is not implemented for AF_INET.

       Since Linux 2.6.27, the type argument serves a second purpose: in addition to specifying a socket type, it may include the bitwise OR of any of the following values, to modify the behavior of socket():

       SOCK_NONBLOCK   Set the O_NONBLOCK file status flag on the new open file description.  Using this flag saves extra calls to fcntl(2) to achieve the same result.

       SOCK_CLOEXEC    Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.  See the description of the O_CLOEXEC flag in open(2) for reasons why this may be useful.

       The protocol specifies a particular protocol to be used with the socket.  Normally only a single protocol exists to support a particular socket type within a given protocol family, in which case protocol can be specified as
       0.  However, it is possible that many protocols may exist, in which case a particular protocol must be specified in this manner.  The protocol number to use is specific to the “communication domain” in  which  communication
       is to take place; see protocols(5).  See getprotoent(3) on how to map protocol name strings to protocol numbers.

       Sockets of type SOCK_STREAM are full-duplex byte streams, similar to pipes.  They do not preserve record boundaries.  A stream socket must be in a connected state before any data may be sent or received on it.  A connection
       to another socket is created with a connect(2) call.  Once connected, data may be transferred using read(2) and write(2) calls or some variant of the send(2) and recv(2) calls.  When a session has been completed a  close(2)
       may be performed.  Out-of-band data may also be transmitted as described in send(2) and received as described in recv(2).

       The  communications protocols which implement a SOCK_STREAM ensure that data is not lost or duplicated.  If a piece of data for which the peer protocol has buffer space cannot be successfully transmitted within a reasonable
       length of time, then the connection is considered to be dead.  When SO_KEEPALIVE is enabled on the socket the protocol checks in a protocol-specific manner if the other end is still alive.  A SIGPIPE signal is raised  if  a
       process  sends  or receives on a broken stream; this causes naive processes, which do not handle the signal, to exit.  SOCK_SEQPACKET sockets employ the same system calls as SOCK_STREAM sockets.  The only difference is that
       read(2) calls will return only the amount of data requested, and any data remaining in the arriving packet will be discarded.  Also all message boundaries in incoming datagrams are preserved.

       SOCK_DGRAM and SOCK_RAW sockets allow sending of datagrams to correspondents named in sendto(2) calls.  Datagrams are generally received with recvfrom(2), which returns the next  datagram  along  with  the  address  of  its
       sender.

       SOCK_PACKET is an obsolete socket type to receive raw packets directly from the device driver.  Use packet(7) instead.

       An fcntl(2) F_SETOWN operation can be used to specify a process or process group to receive a SIGURG signal when the out-of-band data arrives or SIGPIPE signal when a SOCK_STREAM connection breaks unexpectedly.  This opera‐
       tion may also be used to set the process or process group that receives the I/O and asynchronous notification of I/O events via SIGIO.  Using F_SETOWN is equivalent to an ioctl(2) call with the FIOSETOWN or SIOCSPGRP  argu‐
       ment.

       When the network signals an error condition to the protocol module (e.g., using a ICMP message for IP) the pending error flag is set for the socket.  The next operation on this socket will return the error code of the pend‐
       ing error.  For some protocols it is possible to enable a per-socket error queue to retrieve detailed information about the error; see IP_RECVERR in ip(7).

       The operation of sockets is controlled by socket level options.  These options are defined in <sys/socket.h>.  The functions setsockopt(2) and getsockopt(2) are used to set and get options, respectively.

RETURN VALUE
       On success, a file descriptor for the new socket is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES Permission to create a socket of the specified type and/or protocol is denied.

       EAFNOSUPPORT
              The implementation does not support the specified address family.

       EINVAL Unknown protocol, or protocol family not available.

       EINVAL Invalid flags in type.

       EMFILE Process file table overflow.

       ENFILE The system limit on the total number of open files has been reached.

       ENOBUFS or ENOMEM
              Insufficient memory is available.  The socket cannot be created until sufficient resources are freed.

       EPROTONOSUPPORT
              The protocol type or the specified protocol is not supported within this domain.

       Other errors may be generated by the underlying protocol modules.
```

### bind

把`name`绑到socket。
sockaddr的获取通常需要以下几步：
1. gethostname
2. gethostbyname
3. host中的地址填入sockaddr中，再把端口和地址族赋值上


签名
```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

int bind(int sockfd, const struct sockaddr *addr,
        socklen_t addrlen);
```

介绍
```
DESCRIPTION
       When  a  socket is created with socket(2), it exists in a name space (address family) but has no address assigned to it.  bind() assigns the address specified by addr to the socket referred to by the file descriptor sockfd.
       addrlen specifies the size, in bytes, of the address structure pointed to by addr.  Traditionally, this operation is called “assigning a name to a socket”.

       It is normally necessary to assign a local address using bind() before a SOCK_STREAM socket may receive connections (see accept(2)).

       The rules used in name binding vary between address families.  Consult the manual entries in Section 7 for detailed information.  For AF_INET see ip(7), for AF_INET6 see ipv6(7), for AF_UNIX see  unix(7),  for  AF_APPLETALK
       see ddp(7), for AF_PACKET see packet(7), for AF_X25 see x25(7) and for AF_NETLINK see netlink(7).

       The actual structure passed for the addr argument will depend on the address family.  The sockaddr structure is defined as something like:

           struct sockaddr {
               sa_family_t sa_family;
               char        sa_data[14];
           }

       The only purpose of this structure is to cast the structure pointer passed in addr in order to avoid compiler warnings.  See EXAMPLE below.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EACCES The address is protected, and the user is not the superuser.

       EADDRINUSE
              The given address is already in use.

       EBADF  sockfd is not a valid descriptor.

       EINVAL The socket is already bound to an address.

       ENOTSOCK
              sockfd is a descriptor for a file, not a socket.

       The following errors are specific to UNIX domain (AF_UNIX) sockets:

       EACCES Search permission is denied on a component of the path prefix.  (See also path_resolution(7).)

       EADDRNOTAVAIL
              A nonexistent interface was requested or the requested address was not local.

       EFAULT addr points outside the user's accessible address space.

       EINVAL The addrlen is wrong, or the socket was not in the AF_UNIX family.

       ELOOP  Too many symbolic links were encountered in resolving addr.

       ENAMETOOLONG
              addr is too long.

       ENOENT The file does not exist.

       ENOMEM Insufficient kernel memory was available.

       ENOTDIR
              A component of the path prefix is not a directory.

       EROFS  The socket inode would reside on a read-only file system.
```

示例
```c
// An example of the use of bind() with Internet domain sockets can be found in getaddrinfo(3).

// The following example shows how to bind a stream socket in the UNIX (AF_UNIX) domain, and accept connections:

#include <sys/socket.h>
#include <sys/un.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#define MY_SOCK_PATH "/somepath"
#define LISTEN_BACKLOG 50

#define handle_error(msg) \
   do { perror(msg); exit(EXIT_FAILURE); } while (0)

int
main(int argc, char *argv[])
{
   int sfd, cfd;
   struct sockaddr_un my_addr, peer_addr;
   socklen_t peer_addr_size;

   sfd = socket(AF_UNIX, SOCK_STREAM, 0);
   if (sfd == -1)
       handle_error("socket");

   memset(&my_addr, 0, sizeof(struct sockaddr_un));
                       /* Clear structure */
   my_addr.sun_family = AF_UNIX;
   strncpy(my_addr.sun_path, MY_SOCK_PATH,
           sizeof(my_addr.sun_path) - 1);

   if (bind(sfd, (struct sockaddr *) &my_addr,
           sizeof(struct sockaddr_un)) == -1)
       handle_error("bind");

   if (listen(sfd, LISTEN_BACKLOG) == -1)
       handle_error("listen");

   /* Now we can accept incoming connections one
      at a time using accept(2) */

   peer_addr_size = sizeof(struct sockaddr_un);
   cfd = accept(sfd, (struct sockaddr *) &peer_addr,
                &peer_addr_size);
   if (cfd == -1)
       handle_error("accept");

   /* Code to deal with incoming connection(s)... */

   /* When no longer required, the socket pathname, MY_SOCK_PATH
      should be deleted using unlink(2) or remove(3) */
}
```

### listen

把该socket标记为passive（被动），也即用于接收（accept）请求。
> 不是所有类型的socket都能接收接入呼叫，但SOCK_STREAM是可以的


签名
```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

int listen(int sockfd, int backlog);
```

介绍
```
DESCRIPTION
       listen() marks the socket referred to by sockfd as a passive socket, that is, as a socket that will be used to accept incoming connection requests using accept(2).

       The sockfd argument is a file descriptor that refers to a socket of type SOCK_STREAM or SOCK_SEQPACKET.

       The  backlog  argument defines the maximum length to which the queue of pending connections for sockfd may grow.  If a connection request arrives when the queue is full, the client may receive an error with an indication of
       ECONNREFUSED or, if the underlying protocol supports retransmission, the request may be ignored so that a later reattempt at connection succeeds.

RETURN VALUE
       On success, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       EADDRINUSE
              Another socket is already listening on the same port.

       EBADF  The argument sockfd is not a valid descriptor.

       ENOTSOCK
              The argument sockfd is not a socket.

       EOPNOTSUPP
              The socket is not of a type that supports the listen() operation.

```


### accept

接受一个socket连接。
可以传入sockaddr * 和 socklen_t *来获取remote socket信息。

签名
```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

#define _GNU_SOURCE             /* See feature_test_macros(7) */
#include <sys/socket.h>

int accept4(int sockfd, struct sockaddr *addr,
           socklen_t *addrlen, int flags);
```

介绍
```
DESCRIPTION
       The  accept()  system  call is used with connection-based socket types (SOCK_STREAM, SOCK_SEQPACKET).  It extracts the first connection request on the queue of pending connections for the listening socket, sockfd, creates a
       new connected socket, and returns a new file descriptor referring to that socket.  The newly created socket is not in the listening state.  The original socket sockfd is unaffected by this call.

       The argument sockfd is a socket that has been created with socket(2), bound to a local address with bind(2), and is listening for connections after a listen(2).

       The argument addr is a pointer to a sockaddr structure.  This structure is filled in with the address of the peer socket, as known to the communications layer.  The exact format of the address returned addr is determined by
       the socket's address family (see socket(2) and the respective protocol man pages).  When addr is NULL, nothing is filled in; in this case, addrlen is not used, and should also be NULL.

       The addrlen argument is a value-result argument: the caller must initialize it to contain the size (in bytes) of the structure pointed to by addr; on return it will contain the actual size of the peer address.

       The returned address is truncated if the buffer provided is too small; in this case, addrlen will return a value greater than was supplied to the call.

       If  no pending connections are present on the queue, and the socket is not marked as nonblocking, accept() blocks the caller until a connection is present.  If the socket is marked nonblocking and no pending connections are
       present on the queue, accept() fails with the error EAGAIN or EWOULDBLOCK.

       In order to be notified of incoming connections on a socket, you can use select(2) or poll(2).  A readable event will be delivered when a new connection is attempted and you may then call accept() to get a socket  for  that
       connection.  Alternatively, you can set the socket to deliver SIGIO when activity occurs on a socket; see socket(7) for details.

       For  certain protocols which require an explicit confirmation, such as DECNet, accept() can be thought of as merely dequeuing the next connection request and not implying confirmation.  Confirmation can be implied by a nor‐
       mal read or write on the new file descriptor, and rejection can be implied by closing the new socket.  Currently only DECNet has these semantics on Linux.

       If flags is 0, then accept4() is the same as accept().  The following values can be bitwise ORed in flags to obtain different behavior:

       SOCK_NONBLOCK   Set the O_NONBLOCK file status flag on the new open file description.  Using this flag saves extra calls to fcntl(2) to achieve the same result.

       SOCK_CLOEXEC    Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.  See the description of the O_CLOEXEC flag in open(2) for reasons why this may be useful.

RETURN VALUE
       On success, these system calls return a nonnegative integer that is a descriptor for the accepted socket.  On error, -1 is returned, and errno is set appropriately.

   Error handling
       Linux accept() (and accept4()) passes already-pending network errors on the new socket as an error code from accept().  This behavior differs from other BSD socket implementations.  For reliable  operation  the  application
       should  detect the network errors defined for the protocol after accept() and treat them like EAGAIN by retrying.  In the case of TCP/IP, these are ENETDOWN, EPROTO, ENOPROTOOPT, EHOSTDOWN, ENONET, EHOSTUNREACH, EOPNOTSUPP,
       and ENETUNREACH.

ERRORS
       EAGAIN or EWOULDBLOCK
              The socket is marked nonblocking and no connections are present to be accepted.  POSIX.1-2001 allows either error to be returned for this case, and does not require these constants to have the same value, so a porta‐
              ble application should check for both possibilities.

       EBADF  The descriptor is invalid.

       ECONNABORTED
              A connection has been aborted.

       EFAULT The addr argument is not in a writable part of the user address space.

       EINTR  The system call was interrupted by a signal that was caught before a valid connection arrived; see signal(7).

       EINVAL Socket is not listening for connections, or addrlen is invalid (e.g., is negative).

       EINVAL (accept4()) invalid value in flags.

       EMFILE The per-process limit of open file descriptors has been reached.

       ENFILE The system limit on the total number of open files has been reached.

       ENOBUFS, ENOMEM
              Not enough free memory.  This often means that the memory allocation is limited by the socket buffer limits, not by the system memory.

       ENOTSOCK
              The descriptor references a file, not a socket.

       EOPNOTSUPP
              The referenced socket is not of type SOCK_STREAM.

       EPROTO Protocol error.

       In addition, Linux accept() may fail if:

       EPERM  Firewall rules forbid connection.

       In addition, network errors for the new socket and as defined for the protocol may be returned.  Various Linux kernels can return other errors such as ENOSR, ESOCKTNOSUPPORT, EPROTONOSUPPORT, ETIMEDOUT.  The value ERESTART‐
       SYS may be seen during a trace.
```

### read/write
... 前面章节讲过，这里略过。

### close
... 前面章节讲过，这里略过。

> 以上是服务端相关
----------

### connect

发起一个socket连接。

签名
```c
#include <sys/types.h>          /* See NOTES */
#include <sys/socket.h>

int connect(int sockfd, const struct sockaddr *addr,
           socklen_t addrlen);
```

介绍
```
DESCRIPTION
       The connect() system call connects the socket referred to by the file descriptor sockfd to the address specified by addr.  The addrlen argument specifies the size of addr.  The format of the address in addr is determined by
       the address space of the socket sockfd; see socket(2) for further details.

       If the socket sockfd is of type SOCK_DGRAM then addr is the address to which datagrams are sent by default, and the only address from which datagrams are received.  If the socket is of type  SOCK_STREAM  or  SOCK_SEQPACKET,
       this call attempts to make a connection to the socket that is bound to the address specified by addr.

       Generally, connection-based protocol sockets may successfully connect() only once; connectionless protocol sockets may use connect() multiple times to change their association.  Connectionless sockets may dissolve the asso‐
       ciation by connecting to an address with the sa_family member of sockaddr set to AF_UNSPEC (supported on Linux since kernel 2.2).

RETURN VALUE
       If the connection or binding succeeds, zero is returned.  On error, -1 is returned, and errno is set appropriately.

ERRORS
       The following are general socket errors only.  There may be other domain-specific error codes.

       EACCES For UNIX domain sockets, which are identified by pathname: Write permission is denied on the socket file, or search permission is denied for one of the directories in the path prefix.  (See also path_resolution(7).)

       EACCES, EPERM
              The user tried to connect to a broadcast address without having the socket broadcast flag enabled or the connection request failed because of a local firewall rule.

       EADDRINUSE
              Local address is already in use.

       EAFNOSUPPORT
              The passed address didn't have the correct address family in its sa_family field.

       EADDRNOTAVAIL
              Non-existent interface was requested or the requested address was not local.

       EALREADY
              The socket is nonblocking and a previous connection attempt has not yet been completed.

       EBADF  The file descriptor is not a valid index in the descriptor table.

       ECONNREFUSED
              No-one listening on the remote address.

       EFAULT The socket structure address is outside the user's address space.

       EINPROGRESS
              The socket is nonblocking and the connection cannot be completed immediately.  It is possible to select(2) or poll(2) for completion by selecting the socket for writing.  After select(2)  indicates  writability,  use
              getsockopt(2) to read the SO_ERROR option at level SOL_SOCKET to determine whether connect() completed successfully (SO_ERROR is zero) or unsuccessfully (SO_ERROR is one of the usual error codes listed here, explain‐
              ing the reason for the failure).

       EINTR  The system call was interrupted by a signal that was caught; see signal(7).

       EISCONN
              The socket is already connected.

       ENETUNREACH
              Network is unreachable.

       ENOTSOCK
              The file descriptor is not associated with a socket.

       ETIMEDOUT
              Timeout while attempting connection.  The server may be too busy to accept new connections.  Note that for IP sockets the timeout may be very long when syncookies are enabled on the server.
```

### socket type

linux `sock` 调用的manual里提到以下几种：
* SOCK_STREAM
* SOCK_DGRAM
* SOCK_SEQPACKET
* SOCK_RAW
* SOCK_RDM
* SOCK_PACKET

代码中定义enum如下：
```c
/* Types of sockets.  */
enum __socket_type
{
  SOCK_STREAM = 1,		/* Sequenced, reliable, connection-based
				   byte streams.  */
#define SOCK_STREAM SOCK_STREAM
  SOCK_DGRAM = 2,		/* Connectionless, unreliable datagrams
				   of fixed maximum length.  */
#define SOCK_DGRAM SOCK_DGRAM
  SOCK_RAW = 3,			/* Raw protocol interface.  */
#define SOCK_RAW SOCK_RAW
  SOCK_RDM = 4,			/* Reliably-delivered messages.  */
#define SOCK_RDM SOCK_RDM
  SOCK_SEQPACKET = 5,		/* Sequenced, reliable, connection-based,
				   datagrams of fixed maximum length.  */
#define SOCK_SEQPACKET SOCK_SEQPACKET

#define SOCK_MAX (SOCK_SEQPACKET + 1)
  /* Mask which covers at least up to SOCK_MASK-1.
     The remaining bits are used as flags. */
#define SOCK_TYPE_MASK 0xf

  /* Flags to be ORed into the type parameter of socket and socketpair and
     used for the flags parameter of accept4.  */

  SOCK_CLOEXEC = 0x10000000,	/* Atomically set close-on-exec flag for the
				   new descriptor(s).  */
#define SOCK_CLOEXEC SOCK_CLOEXEC

  SOCK_NONBLOCK = 0x20000000	/* Atomically mark descriptor(s) as
				   non-blocking.  */
#define SOCK_NONBLOCK SOCK_NONBLOCK
};
```



### protocol family 和 address family

```
The Windows documentation for socket says that the address family is the first argument; the man page on my Linux box says that that should be the protocol family. The Linux version seems slightly more correct from a platform-agnostic perspective -- in theory, the socket has a protocol family and the addresses have address families, and the two should be compatible.

In practice, though, the PF_ and AF_ macros for the built-in protocols have the same values (in both Linux and Windows). I imagine it's a similar story for most OSes, since all the common protocol families have one address family. (You'd think IP would have two, but nope. There are separate protocol families for IPv4 and IPv6.) This (along with C's relatively weak typing) allows them to be used pretty much interchangeably.

Note that there's no guarantee about this being the case for all OSes, or for protocols supported by some third-party driver, etc. In those cases, you should consult the documentation for your particular platform.

As for what "NS addresses" are, far as i can tell, they're part of Xerox's prehistoric Network Systems protocol (a protocol family sorta like TCP/IP, but distinct and incompatible and unused by modern PCs). You won't see them in use unless you're working with archaic systems; why that was kept as an example is beyond me.
```

PF协议族： socket，在linux socket调用里叫`domain`
AF地址族： addr
需要互相兼容，在实现上经常是相等的值，类似如下：


```c
/* Protocol families.  */
#define	PF_UNSPEC	0	/* Unspecified.  */
#define	PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
#define	PF_UNIX		PF_LOCAL /* Old BSD name for PF_LOCAL.  */
#define	PF_FILE		PF_LOCAL /* POSIX name for PF_LOCAL.  */
#define	PF_INET		2	/* IP protocol family.  */
#define	PF_IMPLINK	3	/* ARPAnet IMP protocol.  */
#define	PF_PUP		4	/* PUP protocols.  */
#define	PF_CHAOS	5	/* MIT Chaos protocols.  */
#define	PF_NS		6	/* Xerox NS protocols.  */
#define	PF_ISO		7	/* ISO protocols.  */
#define	PF_OSI		PF_ISO
#define	PF_ECMA		8	/* ECMA protocols.  */
#define	PF_DATAKIT	9	/* AT&T Datakit protocols.  */
#define	PF_CCITT	10	/* CCITT protocols (X.25 et al).  */
#define	PF_SNA		11	/* IBM SNA protocol.  */
#define	PF_DECnet	12	/* DECnet protocols.  */
#define	PF_DLI		13	/* Direct data link interface.  */
#define	PF_LAT		14	/* DEC Local Area Transport protocol.  */
#define	PF_HYLINK	15	/* NSC Hyperchannel protocol.  */
#define	PF_APPLETALK	16	/* Don't use this.  */
#define	PF_ROUTE	17	/* Internal Routing Protocol.  */
#define	PF_LINK		18	/* Link layer interface.  */
#define	PF_XTP		19	/* eXpress Transfer Protocol (no AF).  */
#define	PF_COIP		20	/* Connection-oriented IP, aka ST II.  */
#define	PF_CNT		21	/* Computer Network Technology.  */
#define PF_RTIP		22	/* Help Identify RTIP packets.  **/
#define	PF_IPX		23	/* Novell Internet Protocol.  */
#define	PF_SIP		24	/* Simple Internet Protocol.  */
#define PF_PIP		25	/* Help Identify PIP packets.  */
#define PF_INET6	26	/* IP version 6.  */
#define	PF_MAX		27

/* Address families.  */
#define	AF_UNSPEC	PF_UNSPEC
#define	AF_LOCAL	PF_LOCAL
#define	AF_UNIX		PF_UNIX
#define	AF_FILE		PF_FILE
#define	AF_INET		PF_INET
#define	AF_IMPLINK	PF_IMPLINK
#define	AF_PUP		PF_PUP
#define	AF_CHAOS	PF_CHAOS
#define	AF_NS		PF_NS
#define	AF_ISO		PF_ISO
#define	AF_OSI		PF_OSI
#define	AF_ECMA		PF_ECMA
#define	AF_DATAKIT	PF_DATAKIT
#define	AF_CCITT	PF_CCITT
#define	AF_SNA		PF_SNA
#define	AF_DECnet	PF_DECnet
#define	AF_DLI		PF_DLI
#define	AF_LAT		PF_LAT
#define	AF_HYLINK	PF_HYLINK
#define	AF_APPLETALK	PF_APPLETALK
#define	AF_ROUTE	PF_ROUTE
#define	AF_LINK		PF_LINK
#define	pseudo_AF_XTP	PF_XTP
#define	AF_COIP		PF_COIP
#define	AF_CNT		PF_CNT
#define pseudo_AF_RTIP	PF_RTIP
#define	AF_IPX		PF_IPX
#define	AF_SIP		PF_SIP
#define pseudo_AF_PIP	PF_PIP
#define AF_INET6	PF_INET6
#define	AF_MAX		PF_MAX
```

linux `socket`调用里有说到domain可以是以下，似乎把PF和AF弄混了：
```
Name                Purpose                          Man page
AF_UNIX, AF_LOCAL   Local communication              unix(7)
AF_INET             IPv4 Internet protocols          ip(7)
AF_INET6            IPv6 Internet protocols          ipv6(7)
AF_IPX              IPX - Novell protocols
AF_NETLINK          Kernel user interface device     netlink(7)
AF_X25              ITU-T X.25 / ISO-8208 protocol   x25(7)
AF_AX25             Amateur radio AX.25 protocol
AF_ATMPVC           Access to raw ATM PVCs
AF_APPLETALK        Appletalk                        ddp(7)
AF_PACKET           Low level packet interface       packet(7)
```


## 编写timeserv.c：时间服务器

### 以电话服务做比的socket相关系统调用
| 行为     | 系统调用     |
| :------------- | :------------- |
| 1. 获取电话线       | socket       |
| 2. 分配号码       | bind       |
| 3. 允许接入调用       | listen       |
| 4. 等待电话       | accept       |
| 5. 传送数据       | read/write       |
| 6. 挂断电话       | close       |

代码间 [timeserv](code/11/timeserv.c)

补充说明
1. socket
> 这一步得到的只是一个fd，只有socket类型等信息，没有bind到地址之前并无实际通信信息
2. bind
> fd + 地址/通信信息，之后才是一个可以提供服务的socket
3. listen
> 类似ready吧..
4. accept
5. read/write
6. close

## 测试timeserv

## 编写timeclnt.c：时间服务器客户端

## 测试timeclnt.c

## 另一种服务器：远程ls

# 软件精灵
daemon

# 小结

TODO
* 本章习题